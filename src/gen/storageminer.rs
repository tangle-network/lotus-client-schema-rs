// Code generated by github.com/tangle-network/lotus-client-schema-rs/rust-schemagen. DO NOT EDIT.

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cid {
    #[serde(rename = "/")]
    pub str: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TipSetKey {
    pub cids: Vec<Cid>,
}

// Code generated by go-schemagen. DO NOT EDIT.

use serde::{Deserialize, Serialize};
use jsonrpc_core::Error;
use serde_json::Value;
use tokio::sync::mpsc;
use std::collections::HashMap;
use uuid::Uuid;
use crate::client::LotusClient;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Address {
    pub str: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddressConfig {
    pub pre_commit_control: Vec<String>,
    pub commit_control: Vec<String>,
    pub terminate_control: Vec<String>,
    pub deal_publish_control: Vec<String>,
    pub disable_owner_fallback: bool,
    pub disable_worker_fallback: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Int {
    pub neg: bool,
    pub abs: Vec<u32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Int1 {
    pub int: Option<Int>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorID {
    pub miner: u64,
    pub number: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorRef {
    pub id: SectorID,
    pub proof_type: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PieceInfo {
    pub size: u64,
    pub piece_cid: Cid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExtendedSectorInfo {
    pub seal_proof: i64,
    pub sector_number: u64,
    pub sector_key: Option<Cid>,
    pub sealed_cid: Cid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PoStProof {
    pub po_st_proof: i64,
    pub proof_bytes: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RLE {
    pub buf: Vec<u8>,
    pub validated: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BitField {
    pub rle: RLE,
    pub set: HashMap<u64, ()>,
    pub unset: HashMap<u64, ()>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PoStPartition {
    pub index: u64,
    pub skipped: BitField,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubmitWindowedPoStParams {
    pub deadline: u64,
    pub partitions: Vec<PoStPartition>,
    pub proofs: Vec<PoStProof>,
    pub chain_commit_epoch: i64,
    pub chain_commit_rand: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertType {
    pub system: String,
    pub subsystem: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Zone {
    pub name: String,
    pub offset: i32,
    pub is_dst: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZoneTrans {
    pub when: i64,
    pub index: u8,
    pub isstd: bool,
    pub isutc: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Location {
    pub name: String,
    pub zone: Vec<Zone>,
    pub tx: Vec<ZoneTrans>,
    pub extend: String,
    pub cache_start: i64,
    pub cache_end: i64,
    pub cache_zone: Option<Zone>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Time {
    pub wall: u64,
    pub ext: i64,
    pub loc: Option<Location>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertEvent {
    #[serde(rename = "type")]
    pub type_: String,
    pub message: Vec<u8>,
    pub time: Time,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventType {
    pub system: String,
    pub event: String,
    pub enabled: bool,
    pub safe: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Alert {
    #[serde(rename = "type")]
    pub type_: AlertType,
    pub active: bool,
    pub last_active: Option<AlertEvent>,
    pub last_resolved: Option<AlertEvent>,
    pub journal_type: EventType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DealLabel {
    pub bs: Vec<u8>,
    pub not_string: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DealProposal {
    pub piece_cid: Cid,
    pub piece_size: u64,
    pub verified_deal: bool,
    pub client: String,
    pub provider: String,
    pub label: DealLabel,
    pub start_epoch: i64,
    pub end_epoch: i64,
    pub storage_price_per_epoch: String,
    pub provider_collateral: String,
    pub client_collateral: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketDealState {
    pub sector_number: u64,
    pub sector_start_epoch: i64,
    pub last_updated_epoch: i64,
    pub slash_epoch: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketDeal {
    pub proposal: DealProposal,
    pub state: MarketDealState,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Ticket {
    pub vrf_proof: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ElectionProof {
    pub win_count: i64,
    pub vrf_proof: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BeaconEntry {
    pub round: u64,
    pub data: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signature {
    #[serde(rename = "type")]
    pub type_: u8,
    pub data: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockHeader {
    pub miner: String,
    pub ticket: Option<Ticket>,
    pub election_proof: Option<ElectionProof>,
    pub beacon_entries: Vec<BeaconEntry>,
    pub win_po_st_proof: Vec<PoStProof>,
    pub parents: Vec<Cid>,
    pub parent_weight: String,
    pub height: i64,
    pub parent_state_root: Cid,
    pub parent_message_receipts: Cid,
    pub messages: Cid,
    pub bls_aggregate: Option<Signature>,
    pub timestamp: u64,
    pub block_sig: Option<Signature>,
    pub fork_signaling: u64,
    pub parent_base_fee: String,
    pub validated: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TipSet {
    pub cids: Vec<Cid>,
    pub blks: Vec<Option<BlockHeader>>,
    pub height: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallID {
    pub sector: SectorID,
    pub id: [u8; 16],
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallError {
    pub code: i32,
    pub message: String,
    pub sub: Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplicaUpdateOut {
    pub new_sealed: Cid,
    pub new_unsealed: Cid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorCids {
    pub unsealed: Cid,
    pub sealed: Cid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DealSchedule {
    pub start_epoch: i64,
    pub end_epoch: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerifiedAllocationKey {
    pub client: u64,
    pub id: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataActivationNotification {
    pub address: String,
    pub payload: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PieceActivationManifest {
    pub cid: Cid,
    pub size: u64,
    pub verified_allocation_key: Option<VerifiedAllocationKey>,
    pub notify: Vec<DataActivationNotification>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PieceDealInfo {
    pub publish_cid: Option<Cid>,
    pub deal_id: u64,
    pub deal_proposal: Option<DealProposal>,
    pub deal_schedule: DealSchedule,
    pub piece_activation_manifest: Option<PieceActivationManifest>,
    pub keep_unsealed: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorOffset {
    pub sector: u64,
    pub offset: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommitBatchRes {
    pub sectors: Vec<u64>,
    pub failed_sectors: HashMap<u64, String>,
    pub msg: Option<Cid>,
    pub error: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NumAssignerMeta {
    pub reserved: BitField,
    pub allocated: BitField,
    pub in_use: BitField,
    pub next: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PreCommitBatchRes {
    pub sectors: Vec<u64>,
    pub msg: Option<Cid>,
    pub error: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorPiece {
    pub piece: PieceInfo,
    pub deal_info: Option<PieceDealInfo>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorPreCommitInfo {
    pub seal_proof: i64,
    pub sector_number: u64,
    pub sealed_cid: Cid,
    pub seal_rand_epoch: i64,
    pub deal_i_ds: Vec<u64>,
    pub expiration: i64,
    pub unsealed_cid: Option<Cid>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorLog {
    pub kind: String,
    pub timestamp: u64,
    pub trace: String,
    pub message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecDataHttpHeader {
    pub key: String,
    pub value: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorLocation {
    pub local: bool,
    pub url: String,
    pub headers: Vec<SecDataHttpHeader>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoteSectorMeta {
    pub state: String,
    pub sector: SectorID,
    #[serde(rename = "type")]
    pub type_: i64,
    pub pieces: Vec<SectorPiece>,
    pub ticket_value: Vec<u8>,
    pub ticket_epoch: i64,
    pub pre_commit1_out: Vec<u8>,
    pub comm_d: Option<Cid>,
    pub comm_r: Option<Cid>,
    pub pre_commit_info: Option<SectorPreCommitInfo>,
    pub pre_commit_deposit: Option<String>,
    pub pre_commit_message: Option<Cid>,
    pub pre_commit_tip_set: TipSetKey,
    pub seed_value: Vec<u8>,
    pub seed_epoch: i64,
    pub commit_proof: Vec<u8>,
    pub commit_message: Option<Cid>,
    pub log: Vec<SectorLog>,
    pub data_unsealed: Option<SectorLocation>,
    pub data_sealed: Option<SectorLocation>,
    pub data_cache: Option<SectorLocation>,
    pub remote_commit1_endpoint: String,
    pub remote_commit2_endpoint: String,
    pub remote_sealing_done_endpoint: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SealedRef {
    pub sector_id: u64,
    pub offset: u64,
    pub size: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SealTicket {
    pub value: Vec<u8>,
    pub epoch: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SealSeed {
    pub value: Vec<u8>,
    pub epoch: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorInfo {
    pub sector_id: u64,
    pub state: String,
    pub comm_d: Option<Cid>,
    pub comm_r: Option<Cid>,
    pub proof: Vec<u8>,
    pub deals: Vec<u64>,
    pub pieces: Vec<SectorPiece>,
    pub ticket: SealTicket,
    pub seed: SealSeed,
    pub pre_commit_msg: Option<Cid>,
    pub commit_msg: Option<Cid>,
    pub retries: u64,
    pub to_upgrade: bool,
    pub replica_update_message: Option<Cid>,
    pub last_err: String,
    pub log: Vec<SectorLog>,
    pub seal_proof: i64,
    pub activation: i64,
    pub expiration: i64,
    pub deal_weight: String,
    pub verified_deal_weight: String,
    pub initial_pledge: String,
    pub on_time: i64,
    pub early: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageInfo {
    pub id: String,
    pub ur_ls: Vec<String>,
    pub weight: u64,
    pub max_storage: u64,
    pub can_seal: bool,
    pub can_store: bool,
    pub groups: Vec<String>,
    pub allow_to: Vec<String>,
    pub allow_types: Vec<String>,
    pub deny_types: Vec<String>,
    pub allow_miners: Vec<String>,
    pub deny_miners: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FsStat {
    pub capacity: i64,
    pub available: i64,
    pub fs_available: i64,
    pub reserved: i64,
    pub max: i64,
    pub used: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorStorageInfo {
    pub id: String,
    pub ur_ls: Vec<String>,
    pub base_ur_ls: Vec<String>,
    pub weight: u64,
    pub can_seal: bool,
    pub can_store: bool,
    pub primary: bool,
    pub allow_types: Vec<String>,
    pub deny_types: Vec<String>,
    pub allow_miners: Vec<String>,
    pub deny_miners: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorLock {
    pub sector: SectorID,
    pub write: [u32; 6],
    pub read: [u32; 6],
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorLocks {
    pub locks: Vec<SectorLock>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Decl {
    pub sector_id: SectorID,
    pub sector_file_type: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthReport {
    pub stat: FsStat,
    pub err: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct APIVersion {
    pub version: String,
    pub api_version: u32,
    pub block_delay: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkerJob {
    pub id: CallID,
    pub sector: SectorID,
    pub task: String,
    pub run_wait: i32,
    pub start: Time,
    #[serde(rename = "")]
    pub hostname: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resources {
    pub min_memory: u64,
    pub max_memory: u64,
    pub gpu_utilization: f64,
    pub max_parallelism: i32,
    pub max_parallelism_gpu: i32,
    pub base_min_memory: u64,
    pub max_concurrent: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkerResources {
    pub mem_physical: u64,
    pub mem_used: u64,
    pub mem_swap: u64,
    pub mem_swap_used: u64,
    pub cp_us: u64,
    pub gp_us: Vec<String>,
    pub resources: HashMap<String, HashMap<i64, Resources>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkerInfo {
    pub hostname: String,
    pub ignore_resources: bool,
    pub resources: WorkerResources,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkerStats {
    pub info: WorkerInfo,
    pub tasks: Vec<String>,
    pub enabled: bool,
    pub mem_used_min: u64,
    pub mem_used_max: u64,
    pub gpu_used: f64,
    pub cpu_use: u64,
    pub task_counts: HashMap<String, i32>,
}

#[async_trait::async_trait]
pub trait StorageMinerApi {
    async fn actor_address(&self) -> Result<String, Error>;
    async fn actor_address_config(&self) -> Result<AddressConfig, Error>;
    async fn actor_sector_size(&self, address: String) -> Result<u64, Error>;
    async fn actor_withdraw_balance(&self, int: String) -> Result<Cid, Error>;
    async fn auth_new(&self, permissions: Vec<String>) -> Result<Vec<u8>, Error>;
    async fn auth_verify(&self, string: String) -> Result<Vec<String>, Error>;
    async fn beneficiary_withdraw_balance(&self, int: String) -> Result<Cid, Error>;
    async fn check_provable(&self, registered_po_st_proof: i64, sector_refs: Vec<SectorRef>) -> Result<HashMap<u64, String>, Error>;
    async fn closing(&self) -> Result<mpsc::Receiver<()>, Error>;
    async fn compute_data_cid(&self, unpadded_piece_size: u64, reader: Value) -> Result<PieceInfo, Error>;
    async fn compute_proof(&self, extended_sector_infos: Vec<ExtendedSectorInfo>, uint8s: Vec<u8>, chain_epoch: i64, version: u32) -> Result<Vec<PoStProof>, Error>;
    async fn compute_window_po_st(&self, uint64: u64, tip_set_key: Option<TipSetKey>) -> Result<Vec<SubmitWindowedPoStParams>, Error>;
    async fn create_backup(&self, string: String) -> Result<(), Error>;
    async fn discover(&self) -> Result<HashMap<String, Value>, Error>;
    async fn log_alerts(&self) -> Result<Vec<Alert>, Error>;
    async fn log_list(&self) -> Result<Vec<String>, Error>;
    async fn log_set_level(&self, string: String, string1: String) -> Result<(), Error>;
    async fn market_list_deals(&self) -> Result<Vec<Option<MarketDeal>>, Error>;
    async fn mining_base(&self) -> Result<Option<TipSet>, Error>;
    async fn pledge_sector(&self) -> Result<SectorID, Error>;
    async fn recover_fault(&self, sector_numbers: Vec<u64>) -> Result<Vec<Cid>, Error>;
    async fn return_add_piece(&self, call_id: CallID, piece_info: PieceInfo, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_data_cid(&self, call_id: CallID, piece_info: PieceInfo, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_download_sector(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_fetch(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_finalize_replica_update(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_finalize_sector(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_generate_sector_key_from_data(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_move_storage(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_prove_replica_update1(&self, call_id: CallID, s: Vec<Vec<u8>>, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_prove_replica_update2(&self, call_id: CallID, uint8s: Vec<u8>, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_read_piece(&self, call_id: CallID, bool: bool, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_release_unsealed(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_replica_update(&self, call_id: CallID, replica_update_out: ReplicaUpdateOut, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_seal_commit1(&self, call_id: CallID, uint8s: Vec<u8>, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_seal_commit2(&self, call_id: CallID, uint8s: Vec<u8>, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_seal_pre_commit1(&self, call_id: CallID, uint8s: Vec<u8>, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_seal_pre_commit2(&self, call_id: CallID, sector_cids: SectorCids, call_error: Option<CallError>) -> Result<(), Error>;
    async fn return_unseal_piece(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error>;
    async fn runtime_subsystems(&self) -> Result<Vec<i32>, Error>;
    async fn sealing_abort(&self, call_id: CallID) -> Result<(), Error>;
    async fn sealing_remove_request(&self, uuid: [u8; 16]) -> Result<(), Error>;
    async fn sealing_sched_diag(&self, bool: bool) -> Result<Value, Error>;
    async fn sector_abort_upgrade(&self, sector_number: u64) -> Result<(), Error>;
    async fn sector_add_piece_to_any(&self, unpadded_piece_size: u64, reader: Value, piece_deal_info: PieceDealInfo) -> Result<SectorOffset, Error>;
    async fn sector_commit_flush(&self) -> Result<Vec<CommitBatchRes>, Error>;
    async fn sector_commit_pending(&self) -> Result<Vec<SectorID>, Error>;
    async fn sector_get_expected_seal_duration(&self) -> Result<i64, Error>;
    async fn sector_get_seal_delay(&self) -> Result<i64, Error>;
    async fn sector_mark_for_upgrade(&self, sector_number: u64, bool: bool) -> Result<(), Error>;
    async fn sector_match_pending_pieces_to_open_sectors(&self) -> Result<(), Error>;
    async fn sector_num_assigner_meta(&self) -> Result<NumAssignerMeta, Error>;
    async fn sector_num_free(&self, string: String) -> Result<(), Error>;
    async fn sector_num_reservations(&self) -> Result<HashMap<String, BitField>, Error>;
    async fn sector_num_reserve(&self, string: String, bit_field: BitField, bool: bool) -> Result<(), Error>;
    async fn sector_num_reserve_count(&self, string: String, uint64: u64) -> Result<BitField, Error>;
    async fn sector_pre_commit_flush(&self) -> Result<Vec<PreCommitBatchRes>, Error>;
    async fn sector_pre_commit_pending(&self) -> Result<Vec<SectorID>, Error>;
    async fn sector_receive(&self, remote_sector_meta: RemoteSectorMeta) -> Result<(), Error>;
    async fn sector_remove(&self, sector_number: u64) -> Result<(), Error>;
    async fn sector_set_expected_seal_duration(&self, duration: i64) -> Result<(), Error>;
    async fn sector_set_seal_delay(&self, duration: i64) -> Result<(), Error>;
    async fn sector_start_sealing(&self, sector_number: u64) -> Result<(), Error>;
    async fn sector_terminate(&self, sector_number: u64) -> Result<(), Error>;
    async fn sector_terminate_flush(&self) -> Result<Option<Cid>, Error>;
    async fn sector_terminate_pending(&self) -> Result<Vec<SectorID>, Error>;
    async fn sector_unseal(&self, sector_number: u64) -> Result<(), Error>;
    async fn sectors_list(&self) -> Result<Vec<u64>, Error>;
    async fn sectors_list_in_states(&self, sector_states: Vec<String>) -> Result<Vec<u64>, Error>;
    async fn sectors_refs(&self) -> Result<HashMap<String, Vec<SealedRef>>, Error>;
    async fn sectors_status(&self, sector_number: u64, bool: bool) -> Result<SectorInfo, Error>;
    async fn sectors_summary(&self) -> Result<HashMap<String, i32>, Error>;
    async fn sectors_unseal_piece(&self, sector_ref: SectorRef, unpadded_byte_index: u64, unpadded_piece_size: u64, uint8s: Vec<u8>, cid: Option<Cid>) -> Result<(), Error>;
    async fn sectors_update(&self, sector_number: u64, sector_state: String) -> Result<(), Error>;
    async fn session(&self) -> Result<[u8; 16], Error>;
    async fn shutdown(&self) -> Result<(), Error>;
    async fn start_time(&self) -> Result<Time, Error>;
    async fn storage_add_local(&self, string: String) -> Result<(), Error>;
    async fn storage_attach(&self, storage_info: StorageInfo, fs_stat: FsStat) -> Result<(), Error>;
    async fn storage_auth_verify(&self, string: String) -> Result<Vec<String>, Error>;
    async fn storage_best_alloc(&self, sector_file_type: i32, sector_size: u64, path_type: String, actor_id: u64) -> Result<Vec<StorageInfo>, Error>;
    async fn storage_declare_sector(&self, id: String, sector_id: SectorID, sector_file_type: i32, bool: bool) -> Result<(), Error>;
    async fn storage_detach(&self, id: String, string: String) -> Result<(), Error>;
    async fn storage_detach_local(&self, string: String) -> Result<(), Error>;
    async fn storage_drop_sector(&self, id: String, sector_id: SectorID, sector_file_type: i32) -> Result<(), Error>;
    async fn storage_find_sector(&self, sector_id: SectorID, sector_file_type: i32, sector_size: u64, bool: bool) -> Result<Vec<SectorStorageInfo>, Error>;
    async fn storage_get_locks(&self) -> Result<SectorLocks, Error>;
    async fn storage_info(&self, id: String) -> Result<StorageInfo, Error>;
    async fn storage_list(&self) -> Result<HashMap<String, Vec<Decl>>, Error>;
    async fn storage_local(&self) -> Result<HashMap<String, String>, Error>;
    async fn storage_lock(&self, sector_id: SectorID, sector_file_type: i32, sector_file_type1: i32) -> Result<(), Error>;
    async fn storage_redeclare_local(&self, id: Option<String>, bool: bool) -> Result<(), Error>;
    async fn storage_report_health(&self, id: String, health_report: HealthReport) -> Result<(), Error>;
    async fn storage_stat(&self, id: String) -> Result<FsStat, Error>;
    async fn storage_try_lock(&self, sector_id: SectorID, sector_file_type: i32, sector_file_type1: i32) -> Result<bool, Error>;
    async fn version(&self) -> Result<APIVersion, Error>;
    async fn worker_connect(&self, string: String) -> Result<(), Error>;
    async fn worker_jobs(&self) -> Result<HashMap<[u8; 16], Vec<WorkerJob>>, Error>;
    async fn worker_stats(&self) -> Result<HashMap<[u8; 16], WorkerStats>, Error>;
}

#[derive(Debug, Clone)]
pub struct StorageMinerClient {
    client: LotusClient,
}

impl StorageMinerClient {
    pub fn new(client: LotusClient) -> Self {
        Self { client }
    }
}

#[async_trait::async_trait]
impl StorageMinerApi for StorageMinerClient {
    async fn actor_address(&self) -> Result<String, Error> {
        let params = vec![];
        self.client.request("Filecoin.ActorAddress", params).await
    }

    async fn actor_address_config(&self) -> Result<AddressConfig, Error> {
        let params = vec![];
        self.client.request("Filecoin.ActorAddressConfig", params).await
    }

    async fn actor_sector_size(&self, address: String) -> Result<u64, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ActorSectorSize", params).await
    }

    async fn actor_withdraw_balance(&self, int: String) -> Result<Cid, Error> {
        let params = vec![
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ActorWithdrawBalance", params).await
    }

    async fn auth_new(&self, permissions: Vec<String>) -> Result<Vec<u8>, Error> {
        let params = vec![
            serde_json::to_value(&permissions).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.AuthNew", params).await
    }

    async fn auth_verify(&self, string: String) -> Result<Vec<String>, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.AuthVerify", params).await
    }

    async fn beneficiary_withdraw_balance(&self, int: String) -> Result<Cid, Error> {
        let params = vec![
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.BeneficiaryWithdrawBalance", params).await
    }

    async fn check_provable(&self, registered_po_st_proof: i64, sector_refs: Vec<SectorRef>) -> Result<HashMap<u64, String>, Error> {
        let params = vec![
            serde_json::to_value(&registered_po_st_proof).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_refs).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.CheckProvable", params).await
    }

    async fn closing(&self) -> Result<mpsc::Receiver<()>, Error> {
        let params = vec![];
        self.client.subscribe("Filecoin.Closing", params).await
    }

    async fn compute_data_cid(&self, unpadded_piece_size: u64, reader: Value) -> Result<PieceInfo, Error> {
        let params = vec![
            serde_json::to_value(&unpadded_piece_size).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&reader).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ComputeDataCid", params).await
    }

    async fn compute_proof(&self, extended_sector_infos: Vec<ExtendedSectorInfo>, uint8s: Vec<u8>, chain_epoch: i64, version: u32) -> Result<Vec<PoStProof>, Error> {
        let params = vec![
            serde_json::to_value(&extended_sector_infos).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&version).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ComputeProof", params).await
    }

    async fn compute_window_po_st(&self, uint64: u64, tip_set_key: Option<TipSetKey>) -> Result<Vec<SubmitWindowedPoStParams>, Error> {
        let params = vec![
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ComputeWindowPoSt", params).await
    }

    async fn create_backup(&self, string: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.CreateBackup", params).await
    }

    async fn discover(&self) -> Result<HashMap<String, Value>, Error> {
        let params = vec![];
        self.client.request("Filecoin.Discover", params).await
    }

    async fn log_alerts(&self) -> Result<Vec<Alert>, Error> {
        let params = vec![];
        self.client.request("Filecoin.LogAlerts", params).await
    }

    async fn log_list(&self) -> Result<Vec<String>, Error> {
        let params = vec![];
        self.client.request("Filecoin.LogList", params).await
    }

    async fn log_set_level(&self, string: String, string1: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&string1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.LogSetLevel", params).await
    }

    async fn market_list_deals(&self) -> Result<Vec<Option<MarketDeal>>, Error> {
        let params = vec![];
        self.client.request("Filecoin.MarketListDeals", params).await
    }

    async fn mining_base(&self) -> Result<Option<TipSet>, Error> {
        let params = vec![];
        self.client.request("Filecoin.MiningBase", params).await
    }

    async fn pledge_sector(&self) -> Result<SectorID, Error> {
        let params = vec![];
        self.client.request("Filecoin.PledgeSector", params).await
    }

    async fn recover_fault(&self, sector_numbers: Vec<u64>) -> Result<Vec<Cid>, Error> {
        let params = vec![
            serde_json::to_value(&sector_numbers).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.RecoverFault", params).await
    }

    async fn return_add_piece(&self, call_id: CallID, piece_info: PieceInfo, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&piece_info).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnAddPiece", params).await
    }

    async fn return_data_cid(&self, call_id: CallID, piece_info: PieceInfo, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&piece_info).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnDataCid", params).await
    }

    async fn return_download_sector(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnDownloadSector", params).await
    }

    async fn return_fetch(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnFetch", params).await
    }

    async fn return_finalize_replica_update(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnFinalizeReplicaUpdate", params).await
    }

    async fn return_finalize_sector(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnFinalizeSector", params).await
    }

    async fn return_generate_sector_key_from_data(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnGenerateSectorKeyFromData", params).await
    }

    async fn return_move_storage(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnMoveStorage", params).await
    }

    async fn return_prove_replica_update1(&self, call_id: CallID, s: Vec<Vec<u8>>, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnProveReplicaUpdate1", params).await
    }

    async fn return_prove_replica_update2(&self, call_id: CallID, uint8s: Vec<u8>, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnProveReplicaUpdate2", params).await
    }

    async fn return_read_piece(&self, call_id: CallID, bool: bool, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnReadPiece", params).await
    }

    async fn return_release_unsealed(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnReleaseUnsealed", params).await
    }

    async fn return_replica_update(&self, call_id: CallID, replica_update_out: ReplicaUpdateOut, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&replica_update_out).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnReplicaUpdate", params).await
    }

    async fn return_seal_commit1(&self, call_id: CallID, uint8s: Vec<u8>, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnSealCommit1", params).await
    }

    async fn return_seal_commit2(&self, call_id: CallID, uint8s: Vec<u8>, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnSealCommit2", params).await
    }

    async fn return_seal_pre_commit1(&self, call_id: CallID, uint8s: Vec<u8>, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnSealPreCommit1", params).await
    }

    async fn return_seal_pre_commit2(&self, call_id: CallID, sector_cids: SectorCids, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_cids).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnSealPreCommit2", params).await
    }

    async fn return_unseal_piece(&self, call_id: CallID, call_error: Option<CallError>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&call_error).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ReturnUnsealPiece", params).await
    }

    async fn runtime_subsystems(&self) -> Result<Vec<i32>, Error> {
        let params = vec![];
        self.client.request("Filecoin.RuntimeSubsystems", params).await
    }

    async fn sealing_abort(&self, call_id: CallID) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&call_id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SealingAbort", params).await
    }

    async fn sealing_remove_request(&self, uuid: [u8; 16]) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&uuid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SealingRemoveRequest", params).await
    }

    async fn sealing_sched_diag(&self, bool: bool) -> Result<Value, Error> {
        let params = vec![
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.SealingSchedDiag", params).await
    }

    async fn sector_abort_upgrade(&self, sector_number: u64) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&sector_number).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SectorAbortUpgrade", params).await
    }

    async fn sector_add_piece_to_any(&self, unpadded_piece_size: u64, reader: Value, piece_deal_info: PieceDealInfo) -> Result<SectorOffset, Error> {
        let params = vec![
            serde_json::to_value(&unpadded_piece_size).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&reader).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&piece_deal_info).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.SectorAddPieceToAny", params).await
    }

    async fn sector_commit_flush(&self) -> Result<Vec<CommitBatchRes>, Error> {
        let params = vec![];
        self.client.request("Filecoin.SectorCommitFlush", params).await
    }

    async fn sector_commit_pending(&self) -> Result<Vec<SectorID>, Error> {
        let params = vec![];
        self.client.request("Filecoin.SectorCommitPending", params).await
    }

    async fn sector_get_expected_seal_duration(&self) -> Result<i64, Error> {
        let params = vec![];
        self.client.request("Filecoin.SectorGetExpectedSealDuration", params).await
    }

    async fn sector_get_seal_delay(&self) -> Result<i64, Error> {
        let params = vec![];
        self.client.request("Filecoin.SectorGetSealDelay", params).await
    }

    async fn sector_mark_for_upgrade(&self, sector_number: u64, bool: bool) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&sector_number).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SectorMarkForUpgrade", params).await
    }

    async fn sector_match_pending_pieces_to_open_sectors(&self) -> Result<(), Error> {
        let params = vec![];
        self.client.request::<()>("Filecoin.SectorMatchPendingPiecesToOpenSectors", params).await
    }

    async fn sector_num_assigner_meta(&self) -> Result<NumAssignerMeta, Error> {
        let params = vec![];
        self.client.request("Filecoin.SectorNumAssignerMeta", params).await
    }

    async fn sector_num_free(&self, string: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SectorNumFree", params).await
    }

    async fn sector_num_reservations(&self) -> Result<HashMap<String, BitField>, Error> {
        let params = vec![];
        self.client.request("Filecoin.SectorNumReservations", params).await
    }

    async fn sector_num_reserve(&self, string: String, bit_field: BitField, bool: bool) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bit_field).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SectorNumReserve", params).await
    }

    async fn sector_num_reserve_count(&self, string: String, uint64: u64) -> Result<BitField, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.SectorNumReserveCount", params).await
    }

    async fn sector_pre_commit_flush(&self) -> Result<Vec<PreCommitBatchRes>, Error> {
        let params = vec![];
        self.client.request("Filecoin.SectorPreCommitFlush", params).await
    }

    async fn sector_pre_commit_pending(&self) -> Result<Vec<SectorID>, Error> {
        let params = vec![];
        self.client.request("Filecoin.SectorPreCommitPending", params).await
    }

    async fn sector_receive(&self, remote_sector_meta: RemoteSectorMeta) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&remote_sector_meta).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SectorReceive", params).await
    }

    async fn sector_remove(&self, sector_number: u64) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&sector_number).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SectorRemove", params).await
    }

    async fn sector_set_expected_seal_duration(&self, duration: i64) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&duration).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SectorSetExpectedSealDuration", params).await
    }

    async fn sector_set_seal_delay(&self, duration: i64) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&duration).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SectorSetSealDelay", params).await
    }

    async fn sector_start_sealing(&self, sector_number: u64) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&sector_number).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SectorStartSealing", params).await
    }

    async fn sector_terminate(&self, sector_number: u64) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&sector_number).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SectorTerminate", params).await
    }

    async fn sector_terminate_flush(&self) -> Result<Option<Cid>, Error> {
        let params = vec![];
        self.client.request("Filecoin.SectorTerminateFlush", params).await
    }

    async fn sector_terminate_pending(&self) -> Result<Vec<SectorID>, Error> {
        let params = vec![];
        self.client.request("Filecoin.SectorTerminatePending", params).await
    }

    async fn sector_unseal(&self, sector_number: u64) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&sector_number).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SectorUnseal", params).await
    }

    async fn sectors_list(&self) -> Result<Vec<u64>, Error> {
        let params = vec![];
        self.client.request("Filecoin.SectorsList", params).await
    }

    async fn sectors_list_in_states(&self, sector_states: Vec<String>) -> Result<Vec<u64>, Error> {
        let params = vec![
            serde_json::to_value(&sector_states).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.SectorsListInStates", params).await
    }

    async fn sectors_refs(&self) -> Result<HashMap<String, Vec<SealedRef>>, Error> {
        let params = vec![];
        self.client.request("Filecoin.SectorsRefs", params).await
    }

    async fn sectors_status(&self, sector_number: u64, bool: bool) -> Result<SectorInfo, Error> {
        let params = vec![
            serde_json::to_value(&sector_number).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.SectorsStatus", params).await
    }

    async fn sectors_summary(&self) -> Result<HashMap<String, i32>, Error> {
        let params = vec![];
        self.client.request("Filecoin.SectorsSummary", params).await
    }

    async fn sectors_unseal_piece(&self, sector_ref: SectorRef, unpadded_byte_index: u64, unpadded_piece_size: u64, uint8s: Vec<u8>, cid: Option<Cid>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&unpadded_byte_index).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&unpadded_piece_size).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SectorsUnsealPiece", params).await
    }

    async fn sectors_update(&self, sector_number: u64, sector_state: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&sector_number).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_state).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SectorsUpdate", params).await
    }

    async fn session(&self) -> Result<[u8; 16], Error> {
        let params = vec![];
        self.client.request("Filecoin.Session", params).await
    }

    async fn shutdown(&self) -> Result<(), Error> {
        let params = vec![];
        self.client.request::<()>("Filecoin.Shutdown", params).await
    }

    async fn start_time(&self) -> Result<Time, Error> {
        let params = vec![];
        self.client.request("Filecoin.StartTime", params).await
    }

    async fn storage_add_local(&self, string: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.StorageAddLocal", params).await
    }

    async fn storage_attach(&self, storage_info: StorageInfo, fs_stat: FsStat) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&storage_info).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&fs_stat).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.StorageAttach", params).await
    }

    async fn storage_auth_verify(&self, string: String) -> Result<Vec<String>, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StorageAuthVerify", params).await
    }

    async fn storage_best_alloc(&self, sector_file_type: i32, sector_size: u64, path_type: String, actor_id: u64) -> Result<Vec<StorageInfo>, Error> {
        let params = vec![
            serde_json::to_value(&sector_file_type).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_size).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&path_type).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&actor_id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StorageBestAlloc", params).await
    }

    async fn storage_declare_sector(&self, id: String, sector_id: SectorID, sector_file_type: i32, bool: bool) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_file_type).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.StorageDeclareSector", params).await
    }

    async fn storage_detach(&self, id: String, string: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.StorageDetach", params).await
    }

    async fn storage_detach_local(&self, string: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.StorageDetachLocal", params).await
    }

    async fn storage_drop_sector(&self, id: String, sector_id: SectorID, sector_file_type: i32) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_file_type).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.StorageDropSector", params).await
    }

    async fn storage_find_sector(&self, sector_id: SectorID, sector_file_type: i32, sector_size: u64, bool: bool) -> Result<Vec<SectorStorageInfo>, Error> {
        let params = vec![
            serde_json::to_value(&sector_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_file_type).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_size).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StorageFindSector", params).await
    }

    async fn storage_get_locks(&self) -> Result<SectorLocks, Error> {
        let params = vec![];
        self.client.request("Filecoin.StorageGetLocks", params).await
    }

    async fn storage_info(&self, id: String) -> Result<StorageInfo, Error> {
        let params = vec![
            serde_json::to_value(&id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StorageInfo", params).await
    }

    async fn storage_list(&self) -> Result<HashMap<String, Vec<Decl>>, Error> {
        let params = vec![];
        self.client.request("Filecoin.StorageList", params).await
    }

    async fn storage_local(&self) -> Result<HashMap<String, String>, Error> {
        let params = vec![];
        self.client.request("Filecoin.StorageLocal", params).await
    }

    async fn storage_lock(&self, sector_id: SectorID, sector_file_type: i32, sector_file_type1: i32) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&sector_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_file_type).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_file_type1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.StorageLock", params).await
    }

    async fn storage_redeclare_local(&self, id: Option<String>, bool: bool) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.StorageRedeclareLocal", params).await
    }

    async fn storage_report_health(&self, id: String, health_report: HealthReport) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&health_report).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.StorageReportHealth", params).await
    }

    async fn storage_stat(&self, id: String) -> Result<FsStat, Error> {
        let params = vec![
            serde_json::to_value(&id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StorageStat", params).await
    }

    async fn storage_try_lock(&self, sector_id: SectorID, sector_file_type: i32, sector_file_type1: i32) -> Result<bool, Error> {
        let params = vec![
            serde_json::to_value(&sector_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_file_type).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_file_type1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StorageTryLock", params).await
    }

    async fn version(&self) -> Result<APIVersion, Error> {
        let params = vec![];
        self.client.request("Filecoin.Version", params).await
    }

    async fn worker_connect(&self, string: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.WorkerConnect", params).await
    }

    async fn worker_jobs(&self) -> Result<HashMap<[u8; 16], Vec<WorkerJob>>, Error> {
        let params = vec![];
        self.client.request("Filecoin.WorkerJobs", params).await
    }

    async fn worker_stats(&self) -> Result<HashMap<[u8; 16], WorkerStats>, Error> {
        let params = vec![];
        self.client.request("Filecoin.WorkerStats", params).await
    }

}
