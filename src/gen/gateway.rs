// Code generated by github.com/tangle-network/lotus-client-schema-rs/rust-schemagen. DO NOT EDIT.

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cid {
    #[serde(rename = "/")]
    pub str: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TipSetKey {
    pub cids: Vec<Cid>,
}

// Code generated by go-schemagen. DO NOT EDIT.

use serde::{Deserialize, Serialize};
use jsonrpc_core::Error;
use serde_json::Value;
use tokio::sync::mpsc;
use std::collections::HashMap;
use uuid::Uuid;
use crate::client::LotusClient;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Address {
    pub str: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Ticket {
    pub vrf_proof: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ElectionProof {
    pub win_count: i64,
    pub vrf_proof: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BeaconEntry {
    pub round: u64,
    pub data: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PoStProof {
    pub po_st_proof: i64,
    pub proof_bytes: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Int {
    pub neg: bool,
    pub abs: Vec<u32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Int1 {
    pub int: Option<Int>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signature {
    #[serde(rename = "type")]
    pub type_: u8,
    pub data: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockHeader {
    pub miner: String,
    pub ticket: Option<Ticket>,
    pub election_proof: Option<ElectionProof>,
    pub beacon_entries: Vec<BeaconEntry>,
    pub win_po_st_proof: Vec<PoStProof>,
    pub parents: Vec<Cid>,
    pub parent_weight: String,
    pub height: i64,
    pub parent_state_root: Cid,
    pub parent_message_receipts: Cid,
    pub messages: Cid,
    pub bls_aggregate: Option<Signature>,
    pub timestamp: u64,
    pub block_sig: Option<Signature>,
    pub fork_signaling: u64,
    pub parent_base_fee: String,
    pub validated: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {
    pub version: u64,
    pub to: String,
    pub from: String,
    pub nonce: u64,
    pub value: String,
    pub gas_limit: i64,
    pub gas_fee_cap: String,
    pub gas_premium: String,
    pub method: u64,
    pub params: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SignedMessage {
    pub message: Message,
    pub signature: Signature,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockMessages {
    pub bls_messages: Vec<Option<Message>>,
    pub secpk_messages: Vec<Option<SignedMessage>>,
    pub cids: Vec<Cid>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventEntry {
    pub flags: u8,
    pub key: String,
    pub codec: u64,
    pub value: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Event {
    pub emitter: u64,
    pub entries: Vec<EventEntry>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TipSet {
    pub cids: Vec<Cid>,
    pub blks: Vec<Option<BlockHeader>>,
    pub height: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message1 {
    pub cid: Cid,
    pub message: Option<Message>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageReceipt {
    pub version: u8,
    pub exit_code: i64,
    #[serde(rename = "return")]
    pub return_: Vec<u8>,
    pub gas_used: i64,
    pub events_root: Option<Cid>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HeadChange {
    #[serde(rename = "type")]
    pub type_: String,
    pub val: Option<TipSet>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthBigInt {
    pub int: Option<Int>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthCall {
    pub from: Option<[u8; 20]>,
    pub to: Option<[u8; 20]>,
    pub gas: u64,
    #[serde(rename = "gasPrice")]
    pub gas_price: EthBigInt,
    pub value: EthBigInt,
    pub data: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthBlockNumberOrHash {
    #[serde(rename = "-")]
    pub predefined_block: Option<String>,
    #[serde(rename = "blockNumber")]
    pub block_number: Option<u64>,
    #[serde(rename = "blockHash")]
    pub block_hash: Option<[u8; 32]>,
    #[serde(rename = "requireCanonical")]
    pub require_canonical: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthFeeHistory {
    #[serde(rename = "oldestBlock")]
    pub oldest_block: u64,
    #[serde(rename = "baseFeePerGas")]
    pub base_fee_per_gas: Vec<EthBigInt>,
    #[serde(rename = "gasUsedRatio")]
    pub gas_used_ratio: Vec<f64>,
    pub reward: Option<Vec<Vec<EthBigInt>>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthBlock {
    pub hash: [u8; 32],
    #[serde(rename = "parentHash")]
    pub parent_hash: [u8; 32],
    #[serde(rename = "sha3Uncles")]
    pub sha3_uncles: [u8; 32],
    pub miner: [u8; 20],
    #[serde(rename = "stateRoot")]
    pub state_root: [u8; 32],
    #[serde(rename = "transactionsRoot")]
    pub transactions_root: [u8; 32],
    #[serde(rename = "receiptsRoot")]
    pub receipts_root: [u8; 32],
    #[serde(rename = "logsBloom")]
    pub logs_bloom: Vec<u8>,
    pub difficulty: u64,
    #[serde(rename = "totalDifficulty")]
    pub total_difficulty: u64,
    pub number: u64,
    #[serde(rename = "gasLimit")]
    pub gas_limit: u64,
    #[serde(rename = "gasUsed")]
    pub gas_used: u64,
    pub timestamp: u64,
    #[serde(rename = "extraData")]
    pub extradata: Vec<u8>,
    #[serde(rename = "mixHash")]
    pub mix_hash: [u8; 32],
    pub nonce: [u8; 8],
    #[serde(rename = "baseFeePerGas")]
    pub base_fee_per_gas: EthBigInt,
    pub size: u64,
    pub transactions: Vec<Value>,
    pub uncles: Vec<[u8; 32]>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthLog {
    pub address: [u8; 20],
    pub data: Vec<u8>,
    pub topics: Vec<[u8; 32]>,
    pub removed: bool,
    #[serde(rename = "logIndex")]
    pub log_index: u64,
    #[serde(rename = "transactionIndex")]
    pub transaction_index: u64,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: [u8; 32],
    #[serde(rename = "blockHash")]
    pub block_hash: [u8; 32],
    #[serde(rename = "blockNumber")]
    pub block_number: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTxReceipt {
    #[serde(rename = "transactionHash")]
    pub transaction_hash: [u8; 32],
    #[serde(rename = "transactionIndex")]
    pub transaction_index: u64,
    #[serde(rename = "blockHash")]
    pub block_hash: [u8; 32],
    #[serde(rename = "blockNumber")]
    pub block_number: u64,
    pub from: [u8; 20],
    pub to: Option<[u8; 20]>,
    #[serde(rename = "root")]
    pub state_root: [u8; 32],
    pub status: u64,
    #[serde(rename = "contractAddress")]
    pub contract_address: Option<[u8; 20]>,
    #[serde(rename = "cumulativeGasUsed")]
    pub cumulative_gas_used: u64,
    #[serde(rename = "gasUsed")]
    pub gas_used: u64,
    #[serde(rename = "effectiveGasPrice")]
    pub effective_gas_price: EthBigInt,
    #[serde(rename = "logsBloom")]
    pub logs_bloom: Vec<u8>,
    pub logs: Vec<EthLog>,
    #[serde(rename = "type")]
    pub type_: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthFilterResult {
    pub results: Vec<Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthFilterSpec {
    #[serde(rename = "fromBlock")]
    pub from_block: Option<String>,
    #[serde(rename = "toBlock")]
    pub to_block: Option<String>,
    pub address: Vec<[u8; 20]>,
    pub topics: Vec<Vec<[u8; 32]>>,
    #[serde(rename = "blockHash")]
    pub block_hash: Option<[u8; 32]>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTx {
    #[serde(rename = "chainId")]
    pub chain_id: u64,
    pub nonce: u64,
    pub hash: [u8; 32],
    #[serde(rename = "blockHash")]
    pub block_hash: Option<[u8; 32]>,
    #[serde(rename = "blockNumber")]
    pub block_number: Option<u64>,
    #[serde(rename = "transactionIndex")]
    pub transaction_index: Option<u64>,
    pub from: [u8; 20],
    pub to: Option<[u8; 20]>,
    pub value: EthBigInt,
    #[serde(rename = "type")]
    pub type_: u64,
    pub input: Vec<u8>,
    pub gas: u64,
    #[serde(rename = "maxFeePerGas")]
    pub max_fee_per_gas: Option<EthBigInt>,
    #[serde(rename = "maxPriorityFeePerGas")]
    pub max_priority_fee_per_gas: Option<EthBigInt>,
    #[serde(rename = "gasPrice")]
    pub gas_price: Option<EthBigInt>,
    #[serde(rename = "accessList")]
    pub access_list: Vec<[u8; 32]>,
    pub v: EthBigInt,
    pub r: EthBigInt,
    pub s: EthBigInt,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthSyncingResult {
    pub done_sync: bool,
    pub starting_block: u64,
    pub current_block: u64,
    pub highest_block: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTrace {
    #[serde(rename = "type")]
    pub type_: String,
    pub error: String,
    pub subtraces: i32,
    #[serde(rename = "traceAddress")]
    pub trace_address: Vec<i32>,
    pub action: Value,
    pub result: Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTraceBlock {
    pub eth_trace: Option<EthTrace>,
    #[serde(rename = "blockHash")]
    pub block_hash: [u8; 32],
    #[serde(rename = "blockNumber")]
    pub block_number: i64,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: [u8; 32],
    #[serde(rename = "transactionPosition")]
    pub transaction_position: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTraceFilterCriteria {
    #[serde(rename = "fromBlock")]
    pub from_block: Option<String>,
    #[serde(rename = "toBlock")]
    pub to_block: Option<String>,
    #[serde(rename = "fromAddress")]
    pub from_address: Vec<[u8; 20]>,
    #[serde(rename = "toAddress")]
    pub to_address: Vec<[u8; 20]>,
    pub after: Option<u64>,
    pub count: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTraceFilterResult {
    pub eth_trace: Option<EthTrace>,
    #[serde(rename = "blockHash")]
    pub block_hash: [u8; 32],
    #[serde(rename = "blockNumber")]
    pub block_number: i64,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: [u8; 32],
    #[serde(rename = "transactionPosition")]
    pub transaction_position: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTraceReplayBlockTransaction {
    pub output: Vec<u8>,
    #[serde(rename = "stateDiff")]
    pub state_diff: Option<String>,
    pub trace: Vec<Option<EthTrace>>,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: [u8; 32],
    #[serde(rename = "vmTrace")]
    pub vm_trace: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTraceTransaction {
    pub eth_trace: Option<EthTrace>,
    #[serde(rename = "blockHash")]
    pub block_hash: [u8; 32],
    #[serde(rename = "blockNumber")]
    pub block_number: i64,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: [u8; 32],
    #[serde(rename = "transactionPosition")]
    pub transaction_position: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSendSpec {
    pub max_fee: String,
    pub msg_uuid: [u8; 16],
    pub maximize_fee_cap: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorEventBlock {
    pub codec: u64,
    pub value: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorEventFilter {
    pub addresses: Vec<String>,
    pub fields: HashMap<String, Vec<ActorEventBlock>>,
    #[serde(rename = "fromHeight")]
    pub from_height: Option<i64>,
    #[serde(rename = "toHeight")]
    pub to_height: Option<i64>,
    #[serde(rename = "tipsetKey")]
    pub tip_set_key: Option<TipSetKey>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorEvent {
    pub entries: Vec<EventEntry>,
    pub emitter: String,
    pub reverted: bool,
    pub height: i64,
    #[serde(rename = "tipsetKey")]
    pub tip_set_key: TipSetKey,
    #[serde(rename = "msgCid")]
    pub msg_cid: Cid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExtendedSectorInfo {
    pub seal_proof: i64,
    pub sector_number: u64,
    pub sector_key: Option<Cid>,
    pub sealed_cid: Cid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MiningBaseInfo {
    pub miner_power: String,
    pub network_power: String,
    pub sectors: Vec<ExtendedSectorInfo>,
    pub worker_key: String,
    pub sector_size: u64,
    pub prev_beacon_entry: BeaconEntry,
    pub beacon_entries: Vec<BeaconEntry>,
    pub eligible_for_mining: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MsigTransaction {
    pub id: i64,
    pub to: String,
    pub value: String,
    pub method: u64,
    pub params: Vec<u8>,
    pub approved: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MsigVesting {
    pub initial_balance: String,
    pub start_epoch: i64,
    pub unlock_duration: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MsgGasCost {
    pub message: Cid,
    pub gas_used: String,
    pub base_fee_burn: String,
    pub over_estimation_burn: String,
    pub miner_penalty: String,
    pub miner_tip: String,
    pub refund: String,
    pub total_cost: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageTrace {
    pub from: String,
    pub to: String,
    pub value: String,
    pub method: u64,
    pub params: Vec<u8>,
    pub params_codec: u64,
    pub gas_limit: u64,
    pub read_only: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReturnTrace {
    pub exit_code: i64,
    #[serde(rename = "return")]
    pub return_: Vec<u8>,
    pub return_codec: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorV5 {
    pub code: Cid,
    pub head: Cid,
    pub nonce: u64,
    pub balance: String,
    pub delegated_address: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorTrace {
    pub id: u64,
    pub state: ActorV5,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GasTrace {
    pub name: String,
    #[serde(rename = "tg")]
    pub total_gas: i64,
    #[serde(rename = "cg")]
    pub compute_gas: i64,
    #[serde(rename = "sg")]
    pub storage_gas: i64,
    #[serde(rename = "tt")]
    pub time_taken: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionTrace {
    pub msg: MessageTrace,
    pub msg_rct: ReturnTrace,
    #[serde(rename = "")]
    pub invoked_actor: Option<ActorTrace>,
    pub gas_charges: Vec<Option<GasTrace>>,
    pub subcalls: Vec<ExecutionTrace>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InvocResult {
    pub msg_cid: Cid,
    pub msg: Option<Message>,
    pub msg_rct: Option<MessageReceipt>,
    pub gas_cost: MsgGasCost,
    pub execution_trace: ExecutionTrace,
    pub error: String,
    pub duration: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DealCollateralBounds {
    pub min: String,
    pub max: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Allocation {
    pub client: u64,
    pub provider: u64,
    pub data: Cid,
    pub size: u64,
    pub term_min: i64,
    pub term_max: i64,
    pub expiration: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Claim {
    pub provider: u64,
    pub client: u64,
    pub data: Cid,
    pub size: u64,
    pub term_min: i64,
    pub term_max: i64,
    pub term_start: i64,
    pub sector: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketBalance {
    pub escrow: String,
    pub locked: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DealLabel {
    pub bs: Vec<u8>,
    pub not_string: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DealProposal {
    pub piece_cid: Cid,
    pub piece_size: u64,
    pub verified_deal: bool,
    pub client: String,
    pub provider: String,
    pub label: DealLabel,
    pub start_epoch: i64,
    pub end_epoch: i64,
    pub storage_price_per_epoch: String,
    pub provider_collateral: String,
    pub client_collateral: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketDealState {
    pub sector_number: u64,
    pub sector_start_epoch: i64,
    pub last_updated_epoch: i64,
    pub slash_epoch: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketDeal {
    pub proposal: DealProposal,
    pub state: MarketDealState,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RLE {
    pub buf: Vec<u8>,
    pub validated: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BitField {
    pub rle: RLE,
    pub set: HashMap<u64, ()>,
    pub unset: HashMap<u64, ()>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Deadline {
    pub post_submissions: BitField,
    pub disputable_proof_count: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BeneficiaryTerm {
    pub quota: String,
    pub used_quota: String,
    pub expiration: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PendingBeneficiaryChange {
    pub new_beneficiary: String,
    pub new_quota: String,
    pub new_expiration: i64,
    pub approved_by_beneficiary: bool,
    pub approved_by_nominee: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MinerInfo {
    pub owner: String,
    pub worker: String,
    pub new_worker: String,
    pub control_addresses: Vec<String>,
    pub worker_change_epoch: i64,
    pub peer_id: Option<String>,
    pub multiaddrs: Vec<Vec<u8>>,
    pub window_po_st_proof_type: i64,
    pub sector_size: u64,
    pub window_po_st_partition_sectors: u64,
    pub consensus_fault_elapsed: i64,
    pub pending_owner_address: Option<String>,
    pub beneficiary: String,
    pub beneficiary_term: Option<BeneficiaryTerm>,
    pub pending_beneficiary_term: Option<PendingBeneficiaryChange>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Claim1 {
    pub raw_byte_power: String,
    pub quality_adj_power: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MinerPower {
    pub miner_power: Claim,
    pub total_power: Claim,
    pub has_min_power: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Info {
    pub current_epoch: i64,
    pub period_start: i64,
    pub index: u64,
    pub open: i64,
    pub close: i64,
    pub challenge: i64,
    pub fault_cutoff: i64,
    pub w_po_st_period_deadlines: u64,
    pub w_po_st_proving_period: i64,
    pub w_po_st_challenge_window: i64,
    pub w_po_st_challenge_lookback: i64,
    pub fault_declaration_cutoff: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MinerSectors {
    pub live: u64,
    pub active: u64,
    pub faulty: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorState {
    pub balance: String,
    pub code: Cid,
    pub state: Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MsgLookup {
    pub message: Cid,
    pub receipt: MessageReceipt,
    pub return_dec: Value,
    pub tip_set: TipSetKey,
    pub height: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorOnChainInfo {
    pub sector_number: u64,
    pub seal_proof: i64,
    pub sealed_cid: Cid,
    pub deal_i_ds: Vec<u64>,
    pub activation: i64,
    pub expiration: i64,
    pub deal_weight: String,
    pub verified_deal_weight: String,
    pub initial_pledge: String,
    pub expected_day_reward: String,
    pub expected_storage_pledge: String,
    pub power_base_epoch: i64,
    pub replaced_day_reward: String,
    pub sector_key_cid: Option<Cid>,
    pub flags: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct APIVersion {
    pub version: String,
    pub api_version: u32,
    pub block_delay: u64,
}

#[async_trait::async_trait]
pub trait GatewayApi {
    async fn chain_get_block(&self, cid: Cid) -> Result<Option<BlockHeader>, Error>;
    async fn chain_get_block_messages(&self, cid: Cid) -> Result<Option<BlockMessages>, Error>;
    async fn chain_get_events(&self, cid: Cid) -> Result<Vec<Event>, Error>;
    async fn chain_get_genesis(&self) -> Result<Option<TipSet>, Error>;
    async fn chain_get_message(&self, cid: Cid) -> Result<Option<Message>, Error>;
    async fn chain_get_parent_messages(&self, cid: Cid) -> Result<Vec<Message>, Error>;
    async fn chain_get_parent_receipts(&self, cid: Cid) -> Result<Vec<Option<MessageReceipt>>, Error>;
    async fn chain_get_path(&self, tip_set_key: Option<TipSetKey>, tip_set_key1: Option<TipSetKey>) -> Result<Vec<Option<HeadChange>>, Error>;
    async fn chain_get_tip_set(&self, tip_set_key: Option<TipSetKey>) -> Result<Option<TipSet>, Error>;
    async fn chain_get_tip_set_after_height(&self, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<Option<TipSet>, Error>;
    async fn chain_get_tip_set_by_height(&self, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<Option<TipSet>, Error>;
    async fn chain_has_obj(&self, cid: Cid) -> Result<bool, Error>;
    async fn chain_head(&self) -> Result<Option<TipSet>, Error>;
    async fn chain_notify(&self) -> Result<mpsc::Receiver<Vec<Option<HeadChange>>>, Error>;
    async fn chain_put_obj(&self, block: Value) -> Result<(), Error>;
    async fn chain_read_obj(&self, cid: Cid) -> Result<Vec<u8>, Error>;
    async fn discover(&self) -> Result<HashMap<String, Value>, Error>;
    async fn eth_accounts(&self) -> Result<Vec<[u8; 20]>, Error>;
    async fn eth_address_to_filecoin_address(&self, eth_address: [u8; 20]) -> Result<String, Error>;
    async fn eth_block_number(&self) -> Result<u64, Error>;
    async fn eth_call(&self, eth_call: EthCall, eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<u8>, Error>;
    async fn eth_chain_id(&self) -> Result<u64, Error>;
    async fn eth_estimate_gas(&self, uint8s: Vec<u8>) -> Result<u64, Error>;
    async fn eth_fee_history(&self, uint8s: Vec<u8>) -> Result<EthFeeHistory, Error>;
    async fn eth_gas_price(&self) -> Result<EthBigInt, Error>;
    async fn eth_get_balance(&self, eth_address: [u8; 20], eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<EthBigInt, Error>;
    async fn eth_get_block_by_hash(&self, eth_hash: [u8; 32], bool: bool) -> Result<EthBlock, Error>;
    async fn eth_get_block_by_number(&self, string: String, bool: bool) -> Result<EthBlock, Error>;
    async fn eth_get_block_receipts(&self, eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<Option<EthTxReceipt>>, Error>;
    async fn eth_get_block_receipts_limited(&self, eth_block_number_or_hash: EthBlockNumberOrHash, chain_epoch: i64) -> Result<Vec<Option<EthTxReceipt>>, Error>;
    async fn eth_get_block_transaction_count_by_hash(&self, eth_hash: [u8; 32]) -> Result<u64, Error>;
    async fn eth_get_block_transaction_count_by_number(&self, eth_uint64: u64) -> Result<u64, Error>;
    async fn eth_get_code(&self, eth_address: [u8; 20], eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<u8>, Error>;
    async fn eth_get_filter_changes(&self, eth_filter_id: [u8; 32]) -> Result<Option<EthFilterResult>, Error>;
    async fn eth_get_filter_logs(&self, eth_filter_id: [u8; 32]) -> Result<Option<EthFilterResult>, Error>;
    async fn eth_get_logs(&self, eth_filter_spec: Option<EthFilterSpec>) -> Result<Option<EthFilterResult>, Error>;
    async fn eth_get_message_cid_by_transaction_hash(&self, eth_hash: Option<[u8; 32]>) -> Result<Option<Cid>, Error>;
    async fn eth_get_storage_at(&self, eth_address: [u8; 20], uint8s: Vec<u8>, eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<u8>, Error>;
    async fn eth_get_transaction_by_hash(&self, eth_hash: Option<[u8; 32]>) -> Result<Option<EthTx>, Error>;
    async fn eth_get_transaction_by_hash_limited(&self, eth_hash: Option<[u8; 32]>, chain_epoch: i64) -> Result<Option<EthTx>, Error>;
    async fn eth_get_transaction_count(&self, eth_address: [u8; 20], eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<u64, Error>;
    async fn eth_get_transaction_hash_by_cid(&self, cid: Cid) -> Result<Option<[u8; 32]>, Error>;
    async fn eth_get_transaction_receipt(&self, eth_hash: [u8; 32]) -> Result<Option<EthTxReceipt>, Error>;
    async fn eth_get_transaction_receipt_limited(&self, eth_hash: [u8; 32], chain_epoch: i64) -> Result<Option<EthTxReceipt>, Error>;
    async fn eth_max_priority_fee_per_gas(&self) -> Result<EthBigInt, Error>;
    async fn eth_new_block_filter(&self) -> Result<[u8; 32], Error>;
    async fn eth_new_filter(&self, eth_filter_spec: Option<EthFilterSpec>) -> Result<[u8; 32], Error>;
    async fn eth_new_pending_transaction_filter(&self) -> Result<[u8; 32], Error>;
    async fn eth_protocol_version(&self) -> Result<u64, Error>;
    async fn eth_send_raw_transaction(&self, uint8s: Vec<u8>) -> Result<[u8; 32], Error>;
    async fn eth_subscribe(&self, uint8s: Vec<u8>) -> Result<[u8; 32], Error>;
    async fn eth_syncing(&self) -> Result<EthSyncingResult, Error>;
    async fn eth_trace_block(&self, string: String) -> Result<Vec<Option<EthTraceBlock>>, Error>;
    async fn eth_trace_filter(&self, eth_trace_filter_criteria: EthTraceFilterCriteria) -> Result<Vec<Option<EthTraceFilterResult>>, Error>;
    async fn eth_trace_replay_block_transactions(&self, string: String, strings: Vec<String>) -> Result<Vec<Option<EthTraceReplayBlockTransaction>>, Error>;
    async fn eth_trace_transaction(&self, string: String) -> Result<Vec<Option<EthTraceTransaction>>, Error>;
    async fn eth_uninstall_filter(&self, eth_filter_id: [u8; 32]) -> Result<bool, Error>;
    async fn eth_unsubscribe(&self, eth_subscription_id: [u8; 32]) -> Result<bool, Error>;
    async fn filecoin_address_to_eth_address(&self, uint8s: Vec<u8>) -> Result<[u8; 20], Error>;
    async fn gas_estimate_gas_premium(&self, uint64: u64, address: String, int64: i64, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn gas_estimate_message_gas(&self, message: Option<Message>, message_send_spec: Option<MessageSendSpec>, tip_set_key: Option<TipSetKey>) -> Result<Option<Message>, Error>;
    async fn get_actor_events_raw(&self, actor_event_filter: Option<ActorEventFilter>) -> Result<Vec<Option<ActorEvent>>, Error>;
    async fn miner_get_base_info(&self, address: String, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<Option<MiningBaseInfo>, Error>;
    async fn mpool_get_nonce(&self, address: String) -> Result<u64, Error>;
    async fn mpool_pending(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<Option<SignedMessage>>, Error>;
    async fn mpool_push(&self, signed_message: Option<SignedMessage>) -> Result<Cid, Error>;
    async fn msig_get_available_balance(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn msig_get_pending(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Vec<Option<MsigTransaction>>, Error>;
    async fn msig_get_vested(&self, address: String, tip_set_key: Option<TipSetKey>, tip_set_key1: Option<TipSetKey>) -> Result<String, Error>;
    async fn msig_get_vesting_schedule(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MsigVesting, Error>;
    async fn net_listening(&self) -> Result<bool, Error>;
    async fn net_version(&self) -> Result<String, Error>;
    async fn state_account_key(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_call(&self, message: Option<Message>, tip_set_key: Option<TipSetKey>) -> Result<Option<InvocResult>, Error>;
    async fn state_deal_provider_collateral_bounds(&self, padded_piece_size: u64, bool: bool, tip_set_key: Option<TipSetKey>) -> Result<DealCollateralBounds, Error>;
    async fn state_decode_params(&self, address: String, method_num: u64, uint8s: Vec<u8>, tip_set_key: Option<TipSetKey>) -> Result<Value, Error>;
    async fn state_get_actor(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<ActorV5>, Error>;
    async fn state_get_allocation(&self, address: String, allocation_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<Allocation>, Error>;
    async fn state_get_allocation_for_pending_deal(&self, deal_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<Allocation>, Error>;
    async fn state_get_allocations(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<HashMap<u64, Allocation>, Error>;
    async fn state_get_claim(&self, address: String, claim_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<Claim>, Error>;
    async fn state_get_claims(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<HashMap<u64, Claim>, Error>;
    async fn state_list_miners(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<String>, Error>;
    async fn state_lookup_id(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_market_balance(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MarketBalance, Error>;
    async fn state_market_storage_deal(&self, deal_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<MarketDeal>, Error>;
    async fn state_miner_deadlines(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Vec<Deadline>, Error>;
    async fn state_miner_info(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MinerInfo, Error>;
    async fn state_miner_power(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<MinerPower>, Error>;
    async fn state_miner_proving_deadline(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<Info>, Error>;
    async fn state_miner_sector_count(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MinerSectors, Error>;
    async fn state_network_name(&self) -> Result<String, Error>;
    async fn state_network_version(&self, tip_set_key: Option<TipSetKey>) -> Result<u32, Error>;
    async fn state_read_state(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<ActorState>, Error>;
    async fn state_replay(&self, tip_set_key: Option<TipSetKey>, cid: Cid) -> Result<Option<InvocResult>, Error>;
    async fn state_search_msg(&self, tip_set_key: Option<TipSetKey>, cid: Cid, chain_epoch: i64, bool: bool) -> Result<Option<MsgLookup>, Error>;
    async fn state_sector_get_info(&self, address: String, sector_number: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<SectorOnChainInfo>, Error>;
    async fn state_verified_client_status(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<String>, Error>;
    async fn state_verifier_status(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<String>, Error>;
    async fn state_wait_msg(&self, cid: Cid, uint64: u64, chain_epoch: i64, bool: bool) -> Result<Option<MsgLookup>, Error>;
    async fn subscribe_actor_events_raw(&self, actor_event_filter: Option<ActorEventFilter>) -> Result<mpsc::Receiver<Option<ActorEvent>>, Error>;
    async fn version(&self) -> Result<APIVersion, Error>;
    async fn wallet_balance(&self, address: String) -> Result<String, Error>;
    async fn web3_client_version(&self) -> Result<String, Error>;
}

#[derive(Debug, Clone)]
pub struct GatewayClient {
    client: LotusClient,
}

impl GatewayClient {
    pub fn new(client: LotusClient) -> Self {
        Self { client }
    }
}

#[async_trait::async_trait]
impl GatewayApi for GatewayClient {
    async fn chain_get_block(&self, cid: Cid) -> Result<Option<BlockHeader>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetBlock", params).await
    }

    async fn chain_get_block_messages(&self, cid: Cid) -> Result<Option<BlockMessages>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetBlockMessages", params).await
    }

    async fn chain_get_events(&self, cid: Cid) -> Result<Vec<Event>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetEvents", params).await
    }

    async fn chain_get_genesis(&self) -> Result<Option<TipSet>, Error> {
        let params = vec![];
        self.client.request("Filecoin.ChainGetGenesis", params).await
    }

    async fn chain_get_message(&self, cid: Cid) -> Result<Option<Message>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetMessage", params).await
    }

    async fn chain_get_parent_messages(&self, cid: Cid) -> Result<Vec<Message>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetParentMessages", params).await
    }

    async fn chain_get_parent_receipts(&self, cid: Cid) -> Result<Vec<Option<MessageReceipt>>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetParentReceipts", params).await
    }

    async fn chain_get_path(&self, tip_set_key: Option<TipSetKey>, tip_set_key1: Option<TipSetKey>) -> Result<Vec<Option<HeadChange>>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetPath", params).await
    }

    async fn chain_get_tip_set(&self, tip_set_key: Option<TipSetKey>) -> Result<Option<TipSet>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetTipSet", params).await
    }

    async fn chain_get_tip_set_after_height(&self, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<Option<TipSet>, Error> {
        let params = vec![
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetTipSetAfterHeight", params).await
    }

    async fn chain_get_tip_set_by_height(&self, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<Option<TipSet>, Error> {
        let params = vec![
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetTipSetByHeight", params).await
    }

    async fn chain_has_obj(&self, cid: Cid) -> Result<bool, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainHasObj", params).await
    }

    async fn chain_head(&self) -> Result<Option<TipSet>, Error> {
        let params = vec![];
        self.client.request("Filecoin.ChainHead", params).await
    }

    async fn chain_notify(&self) -> Result<mpsc::Receiver<Vec<Option<HeadChange>>>, Error> {
        let params = vec![];
        self.client.subscribe("Filecoin.ChainNotify", params).await
    }

    async fn chain_put_obj(&self, block: Value) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&block).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ChainPutObj", params).await
    }

    async fn chain_read_obj(&self, cid: Cid) -> Result<Vec<u8>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainReadObj", params).await
    }

    async fn discover(&self) -> Result<HashMap<String, Value>, Error> {
        let params = vec![];
        self.client.request("Filecoin.Discover", params).await
    }

    async fn eth_accounts(&self) -> Result<Vec<[u8; 20]>, Error> {
        let params = vec![];
        self.client.request("Filecoin.EthAccounts", params).await
    }

    async fn eth_address_to_filecoin_address(&self, eth_address: [u8; 20]) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&eth_address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthAddressToFilecoinAddress", params).await
    }

    async fn eth_block_number(&self) -> Result<u64, Error> {
        let params = vec![];
        self.client.request("Filecoin.EthBlockNumber", params).await
    }

    async fn eth_call(&self, eth_call: EthCall, eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<u8>, Error> {
        let params = vec![
            serde_json::to_value(&eth_call).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&eth_block_number_or_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthCall", params).await
    }

    async fn eth_chain_id(&self) -> Result<u64, Error> {
        let params = vec![];
        self.client.request("Filecoin.EthChainId", params).await
    }

    async fn eth_estimate_gas(&self, uint8s: Vec<u8>) -> Result<u64, Error> {
        let params = vec![
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthEstimateGas", params).await
    }

    async fn eth_fee_history(&self, uint8s: Vec<u8>) -> Result<EthFeeHistory, Error> {
        let params = vec![
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthFeeHistory", params).await
    }

    async fn eth_gas_price(&self) -> Result<EthBigInt, Error> {
        let params = vec![];
        self.client.request("Filecoin.EthGasPrice", params).await
    }

    async fn eth_get_balance(&self, eth_address: [u8; 20], eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<EthBigInt, Error> {
        let params = vec![
            serde_json::to_value(&eth_address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&eth_block_number_or_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetBalance", params).await
    }

    async fn eth_get_block_by_hash(&self, eth_hash: [u8; 32], bool: bool) -> Result<EthBlock, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetBlockByHash", params).await
    }

    async fn eth_get_block_by_number(&self, string: String, bool: bool) -> Result<EthBlock, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetBlockByNumber", params).await
    }

    async fn eth_get_block_receipts(&self, eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<Option<EthTxReceipt>>, Error> {
        let params = vec![
            serde_json::to_value(&eth_block_number_or_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetBlockReceipts", params).await
    }

    async fn eth_get_block_receipts_limited(&self, eth_block_number_or_hash: EthBlockNumberOrHash, chain_epoch: i64) -> Result<Vec<Option<EthTxReceipt>>, Error> {
        let params = vec![
            serde_json::to_value(&eth_block_number_or_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetBlockReceiptsLimited", params).await
    }

    async fn eth_get_block_transaction_count_by_hash(&self, eth_hash: [u8; 32]) -> Result<u64, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetBlockTransactionCountByHash", params).await
    }

    async fn eth_get_block_transaction_count_by_number(&self, eth_uint64: u64) -> Result<u64, Error> {
        let params = vec![
            serde_json::to_value(&eth_uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetBlockTransactionCountByNumber", params).await
    }

    async fn eth_get_code(&self, eth_address: [u8; 20], eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<u8>, Error> {
        let params = vec![
            serde_json::to_value(&eth_address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&eth_block_number_or_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetCode", params).await
    }

    async fn eth_get_filter_changes(&self, eth_filter_id: [u8; 32]) -> Result<Option<EthFilterResult>, Error> {
        let params = vec![
            serde_json::to_value(&eth_filter_id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetFilterChanges", params).await
    }

    async fn eth_get_filter_logs(&self, eth_filter_id: [u8; 32]) -> Result<Option<EthFilterResult>, Error> {
        let params = vec![
            serde_json::to_value(&eth_filter_id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetFilterLogs", params).await
    }

    async fn eth_get_logs(&self, eth_filter_spec: Option<EthFilterSpec>) -> Result<Option<EthFilterResult>, Error> {
        let params = vec![
            serde_json::to_value(&eth_filter_spec).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetLogs", params).await
    }

    async fn eth_get_message_cid_by_transaction_hash(&self, eth_hash: Option<[u8; 32]>) -> Result<Option<Cid>, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetMessageCidByTransactionHash", params).await
    }

    async fn eth_get_storage_at(&self, eth_address: [u8; 20], uint8s: Vec<u8>, eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<u8>, Error> {
        let params = vec![
            serde_json::to_value(&eth_address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&eth_block_number_or_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetStorageAt", params).await
    }

    async fn eth_get_transaction_by_hash(&self, eth_hash: Option<[u8; 32]>) -> Result<Option<EthTx>, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetTransactionByHash", params).await
    }

    async fn eth_get_transaction_by_hash_limited(&self, eth_hash: Option<[u8; 32]>, chain_epoch: i64) -> Result<Option<EthTx>, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetTransactionByHashLimited", params).await
    }

    async fn eth_get_transaction_count(&self, eth_address: [u8; 20], eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<u64, Error> {
        let params = vec![
            serde_json::to_value(&eth_address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&eth_block_number_or_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetTransactionCount", params).await
    }

    async fn eth_get_transaction_hash_by_cid(&self, cid: Cid) -> Result<Option<[u8; 32]>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetTransactionHashByCid", params).await
    }

    async fn eth_get_transaction_receipt(&self, eth_hash: [u8; 32]) -> Result<Option<EthTxReceipt>, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetTransactionReceipt", params).await
    }

    async fn eth_get_transaction_receipt_limited(&self, eth_hash: [u8; 32], chain_epoch: i64) -> Result<Option<EthTxReceipt>, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetTransactionReceiptLimited", params).await
    }

    async fn eth_max_priority_fee_per_gas(&self) -> Result<EthBigInt, Error> {
        let params = vec![];
        self.client.request("Filecoin.EthMaxPriorityFeePerGas", params).await
    }

    async fn eth_new_block_filter(&self) -> Result<[u8; 32], Error> {
        let params = vec![];
        self.client.request("Filecoin.EthNewBlockFilter", params).await
    }

    async fn eth_new_filter(&self, eth_filter_spec: Option<EthFilterSpec>) -> Result<[u8; 32], Error> {
        let params = vec![
            serde_json::to_value(&eth_filter_spec).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthNewFilter", params).await
    }

    async fn eth_new_pending_transaction_filter(&self) -> Result<[u8; 32], Error> {
        let params = vec![];
        self.client.request("Filecoin.EthNewPendingTransactionFilter", params).await
    }

    async fn eth_protocol_version(&self) -> Result<u64, Error> {
        let params = vec![];
        self.client.request("Filecoin.EthProtocolVersion", params).await
    }

    async fn eth_send_raw_transaction(&self, uint8s: Vec<u8>) -> Result<[u8; 32], Error> {
        let params = vec![
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthSendRawTransaction", params).await
    }

    async fn eth_subscribe(&self, uint8s: Vec<u8>) -> Result<[u8; 32], Error> {
        let params = vec![
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthSubscribe", params).await
    }

    async fn eth_syncing(&self) -> Result<EthSyncingResult, Error> {
        let params = vec![];
        self.client.request("Filecoin.EthSyncing", params).await
    }

    async fn eth_trace_block(&self, string: String) -> Result<Vec<Option<EthTraceBlock>>, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthTraceBlock", params).await
    }

    async fn eth_trace_filter(&self, eth_trace_filter_criteria: EthTraceFilterCriteria) -> Result<Vec<Option<EthTraceFilterResult>>, Error> {
        let params = vec![
            serde_json::to_value(&eth_trace_filter_criteria).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthTraceFilter", params).await
    }

    async fn eth_trace_replay_block_transactions(&self, string: String, strings: Vec<String>) -> Result<Vec<Option<EthTraceReplayBlockTransaction>>, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&strings).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthTraceReplayBlockTransactions", params).await
    }

    async fn eth_trace_transaction(&self, string: String) -> Result<Vec<Option<EthTraceTransaction>>, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthTraceTransaction", params).await
    }

    async fn eth_uninstall_filter(&self, eth_filter_id: [u8; 32]) -> Result<bool, Error> {
        let params = vec![
            serde_json::to_value(&eth_filter_id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthUninstallFilter", params).await
    }

    async fn eth_unsubscribe(&self, eth_subscription_id: [u8; 32]) -> Result<bool, Error> {
        let params = vec![
            serde_json::to_value(&eth_subscription_id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthUnsubscribe", params).await
    }

    async fn filecoin_address_to_eth_address(&self, uint8s: Vec<u8>) -> Result<[u8; 20], Error> {
        let params = vec![
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.FilecoinAddressToEthAddress", params).await
    }

    async fn gas_estimate_gas_premium(&self, uint64: u64, address: String, int64: i64, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.GasEstimateGasPremium", params).await
    }

    async fn gas_estimate_message_gas(&self, message: Option<Message>, message_send_spec: Option<MessageSendSpec>, tip_set_key: Option<TipSetKey>) -> Result<Option<Message>, Error> {
        let params = vec![
            serde_json::to_value(&message).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&message_send_spec).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.GasEstimateMessageGas", params).await
    }

    async fn get_actor_events_raw(&self, actor_event_filter: Option<ActorEventFilter>) -> Result<Vec<Option<ActorEvent>>, Error> {
        let params = vec![
            serde_json::to_value(&actor_event_filter).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.GetActorEventsRaw", params).await
    }

    async fn miner_get_base_info(&self, address: String, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<Option<MiningBaseInfo>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MinerGetBaseInfo", params).await
    }

    async fn mpool_get_nonce(&self, address: String) -> Result<u64, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolGetNonce", params).await
    }

    async fn mpool_pending(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<Option<SignedMessage>>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolPending", params).await
    }

    async fn mpool_push(&self, signed_message: Option<SignedMessage>) -> Result<Cid, Error> {
        let params = vec![
            serde_json::to_value(&signed_message).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolPush", params).await
    }

    async fn msig_get_available_balance(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigGetAvailableBalance", params).await
    }

    async fn msig_get_pending(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Vec<Option<MsigTransaction>>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigGetPending", params).await
    }

    async fn msig_get_vested(&self, address: String, tip_set_key: Option<TipSetKey>, tip_set_key1: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigGetVested", params).await
    }

    async fn msig_get_vesting_schedule(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MsigVesting, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigGetVestingSchedule", params).await
    }

    async fn net_listening(&self) -> Result<bool, Error> {
        let params = vec![];
        self.client.request("Filecoin.NetListening", params).await
    }

    async fn net_version(&self) -> Result<String, Error> {
        let params = vec![];
        self.client.request("Filecoin.NetVersion", params).await
    }

    async fn state_account_key(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateAccountKey", params).await
    }

    async fn state_call(&self, message: Option<Message>, tip_set_key: Option<TipSetKey>) -> Result<Option<InvocResult>, Error> {
        let params = vec![
            serde_json::to_value(&message).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateCall", params).await
    }

    async fn state_deal_provider_collateral_bounds(&self, padded_piece_size: u64, bool: bool, tip_set_key: Option<TipSetKey>) -> Result<DealCollateralBounds, Error> {
        let params = vec![
            serde_json::to_value(&padded_piece_size).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateDealProviderCollateralBounds", params).await
    }

    async fn state_decode_params(&self, address: String, method_num: u64, uint8s: Vec<u8>, tip_set_key: Option<TipSetKey>) -> Result<Value, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&method_num).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateDecodeParams", params).await
    }

    async fn state_get_actor(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<ActorV5>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetActor", params).await
    }

    async fn state_get_allocation(&self, address: String, allocation_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<Allocation>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&allocation_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetAllocation", params).await
    }

    async fn state_get_allocation_for_pending_deal(&self, deal_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<Allocation>, Error> {
        let params = vec![
            serde_json::to_value(&deal_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetAllocationForPendingDeal", params).await
    }

    async fn state_get_allocations(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<HashMap<u64, Allocation>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetAllocations", params).await
    }

    async fn state_get_claim(&self, address: String, claim_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<Claim>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&claim_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetClaim", params).await
    }

    async fn state_get_claims(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<HashMap<u64, Claim>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetClaims", params).await
    }

    async fn state_list_miners(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<String>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateListMiners", params).await
    }

    async fn state_lookup_id(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateLookupID", params).await
    }

    async fn state_market_balance(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MarketBalance, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMarketBalance", params).await
    }

    async fn state_market_storage_deal(&self, deal_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<MarketDeal>, Error> {
        let params = vec![
            serde_json::to_value(&deal_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMarketStorageDeal", params).await
    }

    async fn state_miner_deadlines(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Vec<Deadline>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerDeadlines", params).await
    }

    async fn state_miner_info(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MinerInfo, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerInfo", params).await
    }

    async fn state_miner_power(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<MinerPower>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerPower", params).await
    }

    async fn state_miner_proving_deadline(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<Info>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerProvingDeadline", params).await
    }

    async fn state_miner_sector_count(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MinerSectors, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerSectorCount", params).await
    }

    async fn state_network_name(&self) -> Result<String, Error> {
        let params = vec![];
        self.client.request("Filecoin.StateNetworkName", params).await
    }

    async fn state_network_version(&self, tip_set_key: Option<TipSetKey>) -> Result<u32, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateNetworkVersion", params).await
    }

    async fn state_read_state(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<ActorState>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateReadState", params).await
    }

    async fn state_replay(&self, tip_set_key: Option<TipSetKey>, cid: Cid) -> Result<Option<InvocResult>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateReplay", params).await
    }

    async fn state_search_msg(&self, tip_set_key: Option<TipSetKey>, cid: Cid, chain_epoch: i64, bool: bool) -> Result<Option<MsgLookup>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateSearchMsg", params).await
    }

    async fn state_sector_get_info(&self, address: String, sector_number: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<SectorOnChainInfo>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_number).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateSectorGetInfo", params).await
    }

    async fn state_verified_client_status(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<String>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateVerifiedClientStatus", params).await
    }

    async fn state_verifier_status(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<String>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateVerifierStatus", params).await
    }

    async fn state_wait_msg(&self, cid: Cid, uint64: u64, chain_epoch: i64, bool: bool) -> Result<Option<MsgLookup>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateWaitMsg", params).await
    }

    async fn subscribe_actor_events_raw(&self, actor_event_filter: Option<ActorEventFilter>) -> Result<mpsc::Receiver<Option<ActorEvent>>, Error> {
        let params = vec![
            serde_json::to_value(&actor_event_filter).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.subscribe("Filecoin.SubscribeActorEventsRaw", params).await
    }

    async fn version(&self) -> Result<APIVersion, Error> {
        let params = vec![];
        self.client.request("Filecoin.Version", params).await
    }

    async fn wallet_balance(&self, address: String) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.WalletBalance", params).await
    }

    async fn web3_client_version(&self) -> Result<String, Error> {
        let params = vec![];
        self.client.request("Filecoin.Web3ClientVersion", params).await
    }

}
