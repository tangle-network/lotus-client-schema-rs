// Code generated by github.com/tangle-network/lotus-client-schema-rs/rust-schemagen. DO NOT EDIT.

// Code generated by go-schemagen. DO NOT EDIT.

use crate::client::LotusClient;
use jsonrpc_core::Error;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;
use tokio::sync::mpsc;
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorID {
    pub miner: u64,
    pub number: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorRef {
    pub id: SectorID,
    pub proof_type: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallID {
    pub sector: SectorID,
    pub id: [u8; 16],
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecDataHttpHeader {
    pub key: String,
    pub value: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorLocation {
    pub local: bool,
    pub url: String,
    pub headers: Vec<SecDataHttpHeader>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cid {
    pub str: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PostSectorChallenge {
    pub seal_proof: i64,
    pub sector_number: u64,
    pub sealed_cid: Cid,
    pub challenge: Vec<u64>,
    pub update: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PoStProof {
    pub po_st_proof: i64,
    pub proof_bytes: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WindowPoStResult {
    pub po_st_proofs: PoStProof,
    pub skipped: Vec<SectorID>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Resources {
    pub min_memory: u64,
    pub max_memory: u64,
    pub gpu_utilization: f64,
    pub max_parallelism: i32,
    pub max_parallelism_gpu: i32,
    pub base_min_memory: u64,
    pub max_concurrent: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkerResources {
    pub mem_physical: u64,
    pub mem_used: u64,
    pub mem_swap: u64,
    pub mem_swap_used: u64,
    pub cp_us: u64,
    pub gp_us: Vec<String>,
    pub resources: HashMap<String, HashMap<i64, Resources>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkerInfo {
    pub hostname: String,
    pub ignore_resources: bool,
    pub resources: WorkerResources,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StoragePath {
    pub id: String,
    pub weight: u64,
    pub local_path: String,
    pub can_seal: bool,
    pub can_store: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Range {
    pub offset: u64,
    pub size: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PieceInfo {
    pub size: u64,
    pub piece_cid: Cid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorCids {
    pub unsealed: Cid,
    pub sealed: Cid,
}

#[async_trait::async_trait]
pub trait WorkerApi {
    async fn add_piece(
        &self,
        sector_ref: SectorRef,
        unpadded_piece_sizes: Vec<u64>,
        unpadded_piece_size: u64,
        reader: Value,
    ) -> Result<CallID, Error>;
    async fn data_cid(&self, unpadded_piece_size: u64, reader: Value) -> Result<CallID, Error>;
    async fn download_sector_data(
        &self,
        sector_ref: SectorRef,
        bool: bool,
        map: HashMap<i32, SectorLocation>,
    ) -> Result<CallID, Error>;
    async fn enabled(&self) -> Result<bool, Error>;
    async fn fetch(
        &self,
        sector_ref: SectorRef,
        sector_file_type: i32,
        path_type: String,
        acquire_mode: String,
    ) -> Result<CallID, Error>;
    async fn finalize_replica_update(&self, sector_ref: SectorRef) -> Result<CallID, Error>;
    async fn finalize_sector(&self, sector_ref: SectorRef) -> Result<CallID, Error>;
    async fn generate_sector_key_from_data(
        &self,
        sector_ref: SectorRef,
        cid: Cid,
    ) -> Result<CallID, Error>;
    async fn generate_window_po_st(
        &self,
        registered_po_st_proof: i64,
        actor_id: u64,
        post_sector_challenges: Vec<PostSectorChallenge>,
        int: i32,
        uint8s: Vec<u8>,
    ) -> Result<WindowPoStResult, Error>;
    async fn generate_winning_po_st(
        &self,
        registered_po_st_proof: i64,
        actor_id: u64,
        post_sector_challenges: Vec<PostSectorChallenge>,
        uint8s: Vec<u8>,
    ) -> Result<Vec<PoStProof>, Error>;
    async fn info(&self) -> Result<WorkerInfo, Error>;
    async fn move_storage(
        &self,
        sector_ref: SectorRef,
        sector_file_type: i32,
    ) -> Result<CallID, Error>;
    async fn paths(&self) -> Result<Vec<StoragePath>, Error>;
    async fn process_session(&self) -> Result<[u8; 16], Error>;
    async fn prove_replica_update1(
        &self,
        sector_ref: SectorRef,
        cid: Cid,
        cid1: Cid,
        cid2: Cid,
    ) -> Result<CallID, Error>;
    async fn prove_replica_update2(
        &self,
        sector_ref: SectorRef,
        cid: Cid,
        cid1: Cid,
        cid2: Cid,
        s: Vec<Vec<u8>>,
    ) -> Result<CallID, Error>;
    async fn release_unsealed(
        &self,
        sector_ref: SectorRef,
        ranges: Vec<Range>,
    ) -> Result<CallID, Error>;
    async fn remove(&self, sector_id: SectorID) -> Result<(), Error>;
    async fn replica_update(
        &self,
        sector_ref: SectorRef,
        piece_infos: Vec<PieceInfo>,
    ) -> Result<CallID, Error>;
    async fn seal_commit1(
        &self,
        sector_ref: SectorRef,
        uint8s: Vec<u8>,
        uint8s1: Vec<u8>,
        piece_infos: Vec<PieceInfo>,
        sector_cids: SectorCids,
    ) -> Result<CallID, Error>;
    async fn seal_commit2(&self, sector_ref: SectorRef, uint8s: Vec<u8>) -> Result<CallID, Error>;
    async fn seal_pre_commit1(
        &self,
        sector_ref: SectorRef,
        uint8s: Vec<u8>,
        piece_infos: Vec<PieceInfo>,
    ) -> Result<CallID, Error>;
    async fn seal_pre_commit2(
        &self,
        sector_ref: SectorRef,
        uint8s: Vec<u8>,
    ) -> Result<CallID, Error>;
    async fn session(&self) -> Result<[u8; 16], Error>;
    async fn set_enabled(&self, bool: bool) -> Result<(), Error>;
    async fn shutdown(&self) -> Result<(), Error>;
    async fn storage_add_local(&self, string: String) -> Result<(), Error>;
    async fn storage_detach_all(&self) -> Result<(), Error>;
    async fn storage_detach_local(&self, string: String) -> Result<(), Error>;
    async fn storage_local(&self) -> Result<HashMap<String, String>, Error>;
    async fn storage_redeclare_local(&self, id: Option<String>, bool: bool) -> Result<(), Error>;
    async fn task_disable(&self, task_type: String) -> Result<(), Error>;
    async fn task_enable(&self, task_type: String) -> Result<(), Error>;
    async fn task_types(&self) -> Result<HashMap<String, ()>, Error>;
    async fn unseal_piece(
        &self,
        sector_ref: SectorRef,
        unpadded_byte_index: u64,
        unpadded_piece_size: u64,
        uint8s: Vec<u8>,
        cid: Cid,
    ) -> Result<CallID, Error>;
    async fn version(&self) -> Result<u32, Error>;
    async fn wait_quiet(&self) -> Result<(), Error>;
}

#[derive(Debug, Clone)]
pub struct WorkerClient {
    client: LotusClient,
}

impl WorkerClient {
    pub fn new(client: LotusClient) -> Self {
        Self { client }
    }
}

#[async_trait::async_trait]
impl WorkerApi for WorkerClient {
    async fn add_piece(
        &self,
        sector_ref: SectorRef,
        unpadded_piece_sizes: Vec<u64>,
        unpadded_piece_size: u64,
        reader: Value,
    ) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&unpadded_piece_sizes)
                .map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&unpadded_piece_size)
                .map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&reader).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.AddPiece", params).await
    }

    async fn data_cid(&self, unpadded_piece_size: u64, reader: Value) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&unpadded_piece_size)
                .map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&reader).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.DataCid", params).await
    }

    async fn download_sector_data(
        &self,
        sector_ref: SectorRef,
        bool: bool,
        map: HashMap<i32, SectorLocation>,
    ) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&map).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client
            .request("Filecoin.DownloadSectorData", params)
            .await
    }

    async fn enabled(&self) -> Result<bool, Error> {
        let params = vec![];
        self.client.request("Filecoin.Enabled", params).await
    }

    async fn fetch(
        &self,
        sector_ref: SectorRef,
        sector_file_type: i32,
        path_type: String,
        acquire_mode: String,
    ) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_file_type)
                .map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&path_type).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&acquire_mode)
                .map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.Fetch", params).await
    }

    async fn finalize_replica_update(&self, sector_ref: SectorRef) -> Result<CallID, Error> {
        let params =
            vec![serde_json::to_value(&sector_ref)
                .map_err(|e| Error::invalid_params(e.to_string()))?];
        self.client
            .request("Filecoin.FinalizeReplicaUpdate", params)
            .await
    }

    async fn finalize_sector(&self, sector_ref: SectorRef) -> Result<CallID, Error> {
        let params =
            vec![serde_json::to_value(&sector_ref)
                .map_err(|e| Error::invalid_params(e.to_string()))?];
        self.client.request("Filecoin.FinalizeSector", params).await
    }

    async fn generate_sector_key_from_data(
        &self,
        sector_ref: SectorRef,
        cid: Cid,
    ) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client
            .request("Filecoin.GenerateSectorKeyFromData", params)
            .await
    }

    async fn generate_window_po_st(
        &self,
        registered_po_st_proof: i64,
        actor_id: u64,
        post_sector_challenges: Vec<PostSectorChallenge>,
        int: i32,
        uint8s: Vec<u8>,
    ) -> Result<WindowPoStResult, Error> {
        let params = vec![
            serde_json::to_value(&registered_po_st_proof)
                .map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&actor_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&post_sector_challenges)
                .map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client
            .request("Filecoin.GenerateWindowPoSt", params)
            .await
    }

    async fn generate_winning_po_st(
        &self,
        registered_po_st_proof: i64,
        actor_id: u64,
        post_sector_challenges: Vec<PostSectorChallenge>,
        uint8s: Vec<u8>,
    ) -> Result<Vec<PoStProof>, Error> {
        let params = vec![
            serde_json::to_value(&registered_po_st_proof)
                .map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&actor_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&post_sector_challenges)
                .map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client
            .request("Filecoin.GenerateWinningPoSt", params)
            .await
    }

    async fn info(&self) -> Result<WorkerInfo, Error> {
        let params = vec![];
        self.client.request("Filecoin.Info", params).await
    }

    async fn move_storage(
        &self,
        sector_ref: SectorRef,
        sector_file_type: i32,
    ) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_file_type)
                .map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MoveStorage", params).await
    }

    async fn paths(&self) -> Result<Vec<StoragePath>, Error> {
        let params = vec![];
        self.client.request("Filecoin.Paths", params).await
    }

    async fn process_session(&self) -> Result<[u8; 16], Error> {
        let params = vec![];
        self.client.request("Filecoin.ProcessSession", params).await
    }

    async fn prove_replica_update1(
        &self,
        sector_ref: SectorRef,
        cid: Cid,
        cid1: Cid,
        cid2: Cid,
    ) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid2).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client
            .request("Filecoin.ProveReplicaUpdate1", params)
            .await
    }

    async fn prove_replica_update2(
        &self,
        sector_ref: SectorRef,
        cid: Cid,
        cid1: Cid,
        cid2: Cid,
        s: Vec<Vec<u8>>,
    ) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid2).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client
            .request("Filecoin.ProveReplicaUpdate2", params)
            .await
    }

    async fn release_unsealed(
        &self,
        sector_ref: SectorRef,
        ranges: Vec<Range>,
    ) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&ranges).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client
            .request("Filecoin.ReleaseUnsealed", params)
            .await
    }

    async fn remove(&self, sector_id: SectorID) -> Result<(), Error> {
        let params =
            vec![serde_json::to_value(&sector_id)
                .map_err(|e| Error::invalid_params(e.to_string()))?];
        self.client.request::<()>("Filecoin.Remove", params).await
    }

    async fn replica_update(
        &self,
        sector_ref: SectorRef,
        piece_infos: Vec<PieceInfo>,
    ) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&piece_infos).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ReplicaUpdate", params).await
    }

    async fn seal_commit1(
        &self,
        sector_ref: SectorRef,
        uint8s: Vec<u8>,
        uint8s1: Vec<u8>,
        piece_infos: Vec<PieceInfo>,
        sector_cids: SectorCids,
    ) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&piece_infos).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_cids).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.SealCommit1", params).await
    }

    async fn seal_commit2(&self, sector_ref: SectorRef, uint8s: Vec<u8>) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.SealCommit2", params).await
    }

    async fn seal_pre_commit1(
        &self,
        sector_ref: SectorRef,
        uint8s: Vec<u8>,
        piece_infos: Vec<PieceInfo>,
    ) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&piece_infos).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.SealPreCommit1", params).await
    }

    async fn seal_pre_commit2(
        &self,
        sector_ref: SectorRef,
        uint8s: Vec<u8>,
    ) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.SealPreCommit2", params).await
    }

    async fn session(&self) -> Result<[u8; 16], Error> {
        let params = vec![];
        self.client.request("Filecoin.Session", params).await
    }

    async fn set_enabled(&self, bool: bool) -> Result<(), Error> {
        let params =
            vec![serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?];
        self.client
            .request::<()>("Filecoin.SetEnabled", params)
            .await
    }

    async fn shutdown(&self) -> Result<(), Error> {
        let params = vec![];
        self.client.request::<()>("Filecoin.Shutdown", params).await
    }

    async fn storage_add_local(&self, string: String) -> Result<(), Error> {
        let params =
            vec![serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?];
        self.client
            .request::<()>("Filecoin.StorageAddLocal", params)
            .await
    }

    async fn storage_detach_all(&self) -> Result<(), Error> {
        let params = vec![];
        self.client
            .request::<()>("Filecoin.StorageDetachAll", params)
            .await
    }

    async fn storage_detach_local(&self, string: String) -> Result<(), Error> {
        let params =
            vec![serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?];
        self.client
            .request::<()>("Filecoin.StorageDetachLocal", params)
            .await
    }

    async fn storage_local(&self) -> Result<HashMap<String, String>, Error> {
        let params = vec![];
        self.client.request("Filecoin.StorageLocal", params).await
    }

    async fn storage_redeclare_local(&self, id: Option<String>, bool: bool) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client
            .request::<()>("Filecoin.StorageRedeclareLocal", params)
            .await
    }

    async fn task_disable(&self, task_type: String) -> Result<(), Error> {
        let params =
            vec![serde_json::to_value(&task_type)
                .map_err(|e| Error::invalid_params(e.to_string()))?];
        self.client
            .request::<()>("Filecoin.TaskDisable", params)
            .await
    }

    async fn task_enable(&self, task_type: String) -> Result<(), Error> {
        let params =
            vec![serde_json::to_value(&task_type)
                .map_err(|e| Error::invalid_params(e.to_string()))?];
        self.client
            .request::<()>("Filecoin.TaskEnable", params)
            .await
    }

    async fn task_types(&self) -> Result<HashMap<String, ()>, Error> {
        let params = vec![];
        self.client.request("Filecoin.TaskTypes", params).await
    }

    async fn unseal_piece(
        &self,
        sector_ref: SectorRef,
        unpadded_byte_index: u64,
        unpadded_piece_size: u64,
        uint8s: Vec<u8>,
        cid: Cid,
    ) -> Result<CallID, Error> {
        let params = vec![
            serde_json::to_value(&sector_ref).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&unpadded_byte_index)
                .map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&unpadded_piece_size)
                .map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.UnsealPiece", params).await
    }

    async fn version(&self) -> Result<u32, Error> {
        let params = vec![];
        self.client.request("Filecoin.Version", params).await
    }

    async fn wait_quiet(&self) -> Result<(), Error> {
        let params = vec![];
        self.client
            .request::<()>("Filecoin.WaitQuiet", params)
            .await
    }
}
