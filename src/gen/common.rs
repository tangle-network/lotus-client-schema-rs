// Code generated by github.com/tangle-network/lotus-client-schema-rs/rust-schemagen. DO NOT EDIT.

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cid {
    #[serde(rename = "/")]
    pub str: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TipSetKey {
    pub cids: Vec<Cid>,
}

// Code generated by go-schemagen. DO NOT EDIT.

use serde::{Deserialize, Serialize};
use jsonrpc_core::Error;
use serde_json::Value;
use tokio::sync::mpsc;
use std::collections::HashMap;
use uuid::Uuid;
use crate::client::LotusClient;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertType {
    pub system: String,
    pub subsystem: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Zone {
    pub name: String,
    pub offset: i32,
    pub is_dst: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZoneTrans {
    pub when: i64,
    pub index: u8,
    pub isstd: bool,
    pub isutc: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Location {
    pub name: String,
    pub zone: Vec<Zone>,
    pub tx: Vec<ZoneTrans>,
    pub extend: String,
    pub cache_start: i64,
    pub cache_end: i64,
    pub cache_zone: Option<Zone>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Time {
    pub wall: u64,
    pub ext: i64,
    pub loc: Option<Location>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertEvent {
    #[serde(rename = "type")]
    pub type_: String,
    pub message: Vec<u8>,
    pub time: Time,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventType {
    pub system: String,
    pub event: String,
    pub enabled: bool,
    pub safe: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Alert {
    #[serde(rename = "type")]
    pub type_: AlertType,
    pub active: bool,
    pub last_active: Option<AlertEvent>,
    pub last_resolved: Option<AlertEvent>,
    pub journal_type: EventType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct APIVersion {
    pub version: String,
    pub api_version: u32,
    pub block_delay: u64,
}

#[async_trait::async_trait]
pub trait CommonApi {
    async fn auth_new(&self, permissions: Vec<String>) -> Result<Vec<u8>, Error>;
    async fn auth_verify(&self, string: String) -> Result<Vec<String>, Error>;
    async fn closing(&self) -> Result<mpsc::Receiver<()>, Error>;
    async fn discover(&self) -> Result<HashMap<String, Value>, Error>;
    async fn log_alerts(&self) -> Result<Vec<Alert>, Error>;
    async fn log_list(&self) -> Result<Vec<String>, Error>;
    async fn log_set_level(&self, string: String, string1: String) -> Result<(), Error>;
    async fn session(&self) -> Result<[u8; 16], Error>;
    async fn shutdown(&self) -> Result<(), Error>;
    async fn start_time(&self) -> Result<Time, Error>;
    async fn version(&self) -> Result<APIVersion, Error>;
}

#[derive(Debug, Clone)]
pub struct CommonClient {
    client: LotusClient,
}

impl CommonClient {
    pub fn new(client: LotusClient) -> Self {
        Self { client }
    }
}

#[async_trait::async_trait]
impl CommonApi for CommonClient {
    async fn auth_new(&self, permissions: Vec<String>) -> Result<Vec<u8>, Error> {
        let params = vec![
            serde_json::to_value(&permissions).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.AuthNew", params).await
    }

    async fn auth_verify(&self, string: String) -> Result<Vec<String>, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.AuthVerify", params).await
    }

    async fn closing(&self) -> Result<mpsc::Receiver<()>, Error> {
        let params = vec![];
        self.client.subscribe("Filecoin.Closing", params).await
    }

    async fn discover(&self) -> Result<HashMap<String, Value>, Error> {
        let params = vec![];
        self.client.request("Filecoin.Discover", params).await
    }

    async fn log_alerts(&self) -> Result<Vec<Alert>, Error> {
        let params = vec![];
        self.client.request("Filecoin.LogAlerts", params).await
    }

    async fn log_list(&self) -> Result<Vec<String>, Error> {
        let params = vec![];
        self.client.request("Filecoin.LogList", params).await
    }

    async fn log_set_level(&self, string: String, string1: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&string1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.LogSetLevel", params).await
    }

    async fn session(&self) -> Result<[u8; 16], Error> {
        let params = vec![];
        self.client.request("Filecoin.Session", params).await
    }

    async fn shutdown(&self) -> Result<(), Error> {
        let params = vec![];
        self.client.request::<()>("Filecoin.Shutdown", params).await
    }

    async fn start_time(&self) -> Result<Time, Error> {
        let params = vec![];
        self.client.request("Filecoin.StartTime", params).await
    }

    async fn version(&self) -> Result<APIVersion, Error> {
        let params = vec![];
        self.client.request("Filecoin.Version", params).await
    }

}
