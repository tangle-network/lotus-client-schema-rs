// Code generated by github.com/tangle-network/lotus-client-schema-rs/rust-schemagen. DO NOT EDIT.

// Code generated by go-schemagen. DO NOT EDIT.

use crate::client::LotusClient;
use crate::gen::types::{Cid, TipSetKey};
use jsonrpc_core::Error;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;
use tokio::sync::mpsc;
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Address {
    pub str: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyInfo {
    #[serde(rename = "type")]
    pub type_: String,
    pub private_key: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MsgMeta {
    #[serde(rename = "type")]
    pub type_: String,
    pub extra: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signature {
    #[serde(rename = "type")]
    pub type_: u8,
    pub data: Vec<u8>,
}

#[async_trait::async_trait]
pub trait WalletApi {
    async fn wallet_delete(&self, address: String) -> Result<(), Error>;
    async fn wallet_export(&self, address: String) -> Result<Option<KeyInfo>, Error>;
    async fn wallet_has(&self, address: String) -> Result<bool, Error>;
    async fn wallet_import(&self, key_info: Option<KeyInfo>) -> Result<String, Error>;
    async fn wallet_list(&self) -> Result<Vec<String>, Error>;
    async fn wallet_new(&self, key_type: String) -> Result<String, Error>;
    async fn wallet_sign(
        &self,
        address: String,
        uint8s: Vec<u8>,
        msg_meta: MsgMeta,
    ) -> Result<Option<Signature>, Error>;
}

#[derive(Debug, Clone)]
pub struct WalletClient {
    client: LotusClient,
}

impl WalletClient {
    pub fn new(client: LotusClient) -> Self {
        Self { client }
    }
}

#[async_trait::async_trait]
impl WalletApi for WalletClient {
    async fn wallet_delete(&self, address: String) -> Result<(), Error> {
        let params =
            vec![serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?];
        self.client
            .request::<()>("Filecoin.WalletDelete", params)
            .await
    }

    async fn wallet_export(&self, address: String) -> Result<Option<KeyInfo>, Error> {
        let params =
            vec![serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?];
        self.client.request("Filecoin.WalletExport", params).await
    }

    async fn wallet_has(&self, address: String) -> Result<bool, Error> {
        let params =
            vec![serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?];
        self.client.request("Filecoin.WalletHas", params).await
    }

    async fn wallet_import(&self, key_info: Option<KeyInfo>) -> Result<String, Error> {
        let params =
            vec![serde_json::to_value(&key_info)
                .map_err(|e| Error::invalid_params(e.to_string()))?];
        self.client.request("Filecoin.WalletImport", params).await
    }

    async fn wallet_list(&self) -> Result<Vec<String>, Error> {
        let params = vec![];
        self.client.request("Filecoin.WalletList", params).await
    }

    async fn wallet_new(&self, key_type: String) -> Result<String, Error> {
        let params =
            vec![serde_json::to_value(&key_type)
                .map_err(|e| Error::invalid_params(e.to_string()))?];
        self.client.request("Filecoin.WalletNew", params).await
    }

    async fn wallet_sign(
        &self,
        address: String,
        uint8s: Vec<u8>,
        msg_meta: MsgMeta,
    ) -> Result<Option<Signature>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&msg_meta).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.WalletSign", params).await
    }
}
