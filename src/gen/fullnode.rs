// Code generated by github.com/tangle-network/lotus-client-schema-rs/rust-schemagen. DO NOT EDIT.

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cid {
    #[serde(rename = "/")]
    pub str: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TipSetKey {
    pub cids: Vec<Cid>,
}

// Code generated by go-schemagen. DO NOT EDIT.

use serde::{Deserialize, Serialize};
use jsonrpc_core::Error;
use serde_json::Value;
use tokio::sync::mpsc;
use std::collections::HashMap;
use uuid::Uuid;
use crate::client::LotusClient;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChainExportConfig {
    pub write_buffer_size: i32,
    pub num_workers: i32,
    pub include_messages: bool,
    pub include_receipts: bool,
    pub include_state_roots: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Address {
    pub str: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Ticket {
    pub vrf_proof: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ElectionProof {
    pub win_count: i64,
    pub vrf_proof: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BeaconEntry {
    pub round: u64,
    pub data: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PoStProof {
    pub po_st_proof: i64,
    pub proof_bytes: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Int {
    pub neg: bool,
    pub abs: Vec<u32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Int1 {
    pub int: Option<Int>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signature {
    #[serde(rename = "type")]
    pub type_: u8,
    pub data: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockHeader {
    pub miner: String,
    pub ticket: Option<Ticket>,
    pub election_proof: Option<ElectionProof>,
    pub beacon_entries: Vec<BeaconEntry>,
    pub win_po_st_proof: Vec<PoStProof>,
    pub parents: Vec<Cid>,
    pub parent_weight: String,
    pub height: i64,
    pub parent_state_root: Cid,
    pub parent_message_receipts: Cid,
    pub messages: Cid,
    pub bls_aggregate: Option<Signature>,
    pub timestamp: u64,
    pub block_sig: Option<Signature>,
    pub fork_signaling: u64,
    pub parent_base_fee: String,
    pub validated: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {
    pub version: u64,
    pub to: String,
    pub from: String,
    pub nonce: u64,
    pub value: String,
    pub gas_limit: i64,
    pub gas_fee_cap: String,
    pub gas_premium: String,
    pub method: u64,
    pub params: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SignedMessage {
    pub message: Message,
    pub signature: Signature,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockMessages {
    pub bls_messages: Vec<Option<Message>>,
    pub secpk_messages: Vec<Option<SignedMessage>>,
    pub cids: Vec<Cid>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventEntry {
    pub flags: u8,
    pub key: String,
    pub codec: u64,
    pub value: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Event {
    pub emitter: u64,
    pub entries: Vec<EventEntry>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TipSet {
    pub cids: Vec<Cid>,
    pub blks: Vec<Option<BlockHeader>>,
    pub height: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message1 {
    pub cid: Cid,
    pub message: Option<Message>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IpldObject {
    pub cid: Cid,
    pub obj: Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageReceipt {
    pub version: u8,
    pub exit_code: i64,
    #[serde(rename = "return")]
    pub return_: Vec<u8>,
    pub gas_used: i64,
    pub events_root: Option<Cid>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HeadChange {
    #[serde(rename = "type")]
    pub type_: String,
    pub val: Option<TipSet>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HotGCOpts {
    pub threshold: f64,
    pub periodic: bool,
    pub moving: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PruneOpts {
    pub moving_gc: bool,
    pub retain_state: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObjStat {
    pub size: u64,
    pub links: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthBigInt {
    pub int: Option<Int>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthCall {
    pub from: Option<[u8; 20]>,
    pub to: Option<[u8; 20]>,
    pub gas: u64,
    #[serde(rename = "gasPrice")]
    pub gas_price: EthBigInt,
    pub value: EthBigInt,
    pub data: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthBlockNumberOrHash {
    #[serde(rename = "-")]
    pub predefined_block: Option<String>,
    #[serde(rename = "blockNumber")]
    pub block_number: Option<u64>,
    #[serde(rename = "blockHash")]
    pub block_hash: Option<[u8; 32]>,
    #[serde(rename = "requireCanonical")]
    pub require_canonical: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthFeeHistory {
    #[serde(rename = "oldestBlock")]
    pub oldest_block: u64,
    #[serde(rename = "baseFeePerGas")]
    pub base_fee_per_gas: Vec<EthBigInt>,
    #[serde(rename = "gasUsedRatio")]
    pub gas_used_ratio: Vec<f64>,
    pub reward: Option<Vec<Vec<EthBigInt>>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthBlock {
    pub hash: [u8; 32],
    #[serde(rename = "parentHash")]
    pub parent_hash: [u8; 32],
    #[serde(rename = "sha3Uncles")]
    pub sha3_uncles: [u8; 32],
    pub miner: [u8; 20],
    #[serde(rename = "stateRoot")]
    pub state_root: [u8; 32],
    #[serde(rename = "transactionsRoot")]
    pub transactions_root: [u8; 32],
    #[serde(rename = "receiptsRoot")]
    pub receipts_root: [u8; 32],
    #[serde(rename = "logsBloom")]
    pub logs_bloom: Vec<u8>,
    pub difficulty: u64,
    #[serde(rename = "totalDifficulty")]
    pub total_difficulty: u64,
    pub number: u64,
    #[serde(rename = "gasLimit")]
    pub gas_limit: u64,
    #[serde(rename = "gasUsed")]
    pub gas_used: u64,
    pub timestamp: u64,
    #[serde(rename = "extraData")]
    pub extradata: Vec<u8>,
    #[serde(rename = "mixHash")]
    pub mix_hash: [u8; 32],
    pub nonce: [u8; 8],
    #[serde(rename = "baseFeePerGas")]
    pub base_fee_per_gas: EthBigInt,
    pub size: u64,
    pub transactions: Vec<Value>,
    pub uncles: Vec<[u8; 32]>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthLog {
    pub address: [u8; 20],
    pub data: Vec<u8>,
    pub topics: Vec<[u8; 32]>,
    pub removed: bool,
    #[serde(rename = "logIndex")]
    pub log_index: u64,
    #[serde(rename = "transactionIndex")]
    pub transaction_index: u64,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: [u8; 32],
    #[serde(rename = "blockHash")]
    pub block_hash: [u8; 32],
    #[serde(rename = "blockNumber")]
    pub block_number: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTxReceipt {
    #[serde(rename = "transactionHash")]
    pub transaction_hash: [u8; 32],
    #[serde(rename = "transactionIndex")]
    pub transaction_index: u64,
    #[serde(rename = "blockHash")]
    pub block_hash: [u8; 32],
    #[serde(rename = "blockNumber")]
    pub block_number: u64,
    pub from: [u8; 20],
    pub to: Option<[u8; 20]>,
    #[serde(rename = "root")]
    pub state_root: [u8; 32],
    pub status: u64,
    #[serde(rename = "contractAddress")]
    pub contract_address: Option<[u8; 20]>,
    #[serde(rename = "cumulativeGasUsed")]
    pub cumulative_gas_used: u64,
    #[serde(rename = "gasUsed")]
    pub gas_used: u64,
    #[serde(rename = "effectiveGasPrice")]
    pub effective_gas_price: EthBigInt,
    #[serde(rename = "logsBloom")]
    pub logs_bloom: Vec<u8>,
    pub logs: Vec<EthLog>,
    #[serde(rename = "type")]
    pub type_: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthFilterResult {
    pub results: Vec<Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthFilterSpec {
    #[serde(rename = "fromBlock")]
    pub from_block: Option<String>,
    #[serde(rename = "toBlock")]
    pub to_block: Option<String>,
    pub address: Vec<[u8; 20]>,
    pub topics: Vec<Vec<[u8; 32]>>,
    #[serde(rename = "blockHash")]
    pub block_hash: Option<[u8; 32]>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTx {
    #[serde(rename = "chainId")]
    pub chain_id: u64,
    pub nonce: u64,
    pub hash: [u8; 32],
    #[serde(rename = "blockHash")]
    pub block_hash: Option<[u8; 32]>,
    #[serde(rename = "blockNumber")]
    pub block_number: Option<u64>,
    #[serde(rename = "transactionIndex")]
    pub transaction_index: Option<u64>,
    pub from: [u8; 20],
    pub to: Option<[u8; 20]>,
    pub value: EthBigInt,
    #[serde(rename = "type")]
    pub type_: u64,
    pub input: Vec<u8>,
    pub gas: u64,
    #[serde(rename = "maxFeePerGas")]
    pub max_fee_per_gas: Option<EthBigInt>,
    #[serde(rename = "maxPriorityFeePerGas")]
    pub max_priority_fee_per_gas: Option<EthBigInt>,
    #[serde(rename = "gasPrice")]
    pub gas_price: Option<EthBigInt>,
    #[serde(rename = "accessList")]
    pub access_list: Vec<[u8; 32]>,
    pub v: EthBigInt,
    pub r: EthBigInt,
    pub s: EthBigInt,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthSyncingResult {
    pub done_sync: bool,
    pub starting_block: u64,
    pub current_block: u64,
    pub highest_block: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTrace {
    #[serde(rename = "type")]
    pub type_: String,
    pub error: String,
    pub subtraces: i32,
    #[serde(rename = "traceAddress")]
    pub trace_address: Vec<i32>,
    pub action: Value,
    pub result: Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTraceBlock {
    pub eth_trace: Option<EthTrace>,
    #[serde(rename = "blockHash")]
    pub block_hash: [u8; 32],
    #[serde(rename = "blockNumber")]
    pub block_number: i64,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: [u8; 32],
    #[serde(rename = "transactionPosition")]
    pub transaction_position: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTraceFilterCriteria {
    #[serde(rename = "fromBlock")]
    pub from_block: Option<String>,
    #[serde(rename = "toBlock")]
    pub to_block: Option<String>,
    #[serde(rename = "fromAddress")]
    pub from_address: Vec<[u8; 20]>,
    #[serde(rename = "toAddress")]
    pub to_address: Vec<[u8; 20]>,
    pub after: Option<u64>,
    pub count: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTraceFilterResult {
    pub eth_trace: Option<EthTrace>,
    #[serde(rename = "blockHash")]
    pub block_hash: [u8; 32],
    #[serde(rename = "blockNumber")]
    pub block_number: i64,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: [u8; 32],
    #[serde(rename = "transactionPosition")]
    pub transaction_position: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTraceReplayBlockTransaction {
    pub output: Vec<u8>,
    #[serde(rename = "stateDiff")]
    pub state_diff: Option<String>,
    pub trace: Vec<Option<EthTrace>>,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: [u8; 32],
    #[serde(rename = "vmTrace")]
    pub vm_trace: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthTraceTransaction {
    pub eth_trace: Option<EthTrace>,
    #[serde(rename = "blockHash")]
    pub block_hash: [u8; 32],
    #[serde(rename = "blockNumber")]
    pub block_number: i64,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: [u8; 32],
    #[serde(rename = "transactionPosition")]
    pub transaction_position: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TipSet1 {
    pub epoch: i64,
    pub key: Vec<u8>,
    pub power_table: Cid,
    pub commitments: [u8; 32],
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupplementalData {
    pub commitments: [u8; 32],
    pub power_table: Cid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RLE {
    pub buf: Vec<u8>,
    pub validated: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BitField {
    pub rle: RLE,
    pub set: HashMap<u64, ()>,
    pub unset: HashMap<u64, ()>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PowerTableDelta {
    pub participant_id: u64,
    pub power_delta: String,
    pub signing_key: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FinalityCertificate {
    pub gpbft_instance: u64,
    pub ec_chain: Vec<TipSet>,
    pub supplemental_data: SupplementalData,
    pub signers: BitField,
    pub signature: Vec<u8>,
    pub power_table_delta: Vec<PowerTableDelta>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PowerEntry {
    pub id: u64,
    pub power: String,
    pub pub_key: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GpbftConfig {
    pub delta: i64,
    pub delta_back_off_exponent: f64,
    pub max_lookahead_rounds: u64,
    pub rebroadcast_backoff_base: i64,
    pub rebroadcast_backoff_exponent: f64,
    pub rebroadcast_backoff_spread: f64,
    pub rebroadcast_backoff_max: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EcConfig {
    pub period: i64,
    pub finality: i64,
    pub delay_multiplier: f64,
    pub base_decision_backoff_table: Vec<f64>,
    pub head_lookback: i32,
    pub finalize: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CxConfig {
    pub client_request_timeout: i64,
    pub server_request_timeout: i64,
    pub minimum_poll_interval: i64,
    pub maximum_poll_interval: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Manifest {
    pub pause: bool,
    pub protocol_version: u64,
    pub initial_instance: u64,
    pub bootstrap_epoch: i64,
    pub network_name: String,
    pub explicit_power: Vec<PowerEntry>,
    pub ignore_ec_power: bool,
    pub initial_power_table: Cid,
    pub committee_lookback: u64,
    pub catch_up_alignment: i64,
    pub gpbft: GpbftConfig,
    pub ec: EcConfig,
    pub certificate_exchange: CxConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Instant {
    pub id: u64,
    pub round: u64,
    pub phase: u8,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct F3Participant {
    pub miner_id: u64,
    pub from_instance: u64,
    pub validity_term: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct F3ParticipationLease {
    pub network: String,
    pub issuer: String,
    pub miner_id: u64,
    pub from_instance: u64,
    pub validity_term: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSendSpec {
    pub max_fee: String,
    pub msg_uuid: [u8; 16],
    pub maximize_fee_cap: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorEventBlock {
    pub codec: u64,
    pub value: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorEventFilter {
    pub addresses: Vec<String>,
    pub fields: HashMap<String, Vec<ActorEventBlock>>,
    #[serde(rename = "fromHeight")]
    pub from_height: Option<i64>,
    #[serde(rename = "toHeight")]
    pub to_height: Option<i64>,
    #[serde(rename = "tipsetKey")]
    pub tip_set_key: Option<TipSetKey>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorEvent {
    pub entries: Vec<EventEntry>,
    pub emitter: String,
    pub reverted: bool,
    pub height: i64,
    #[serde(rename = "tipsetKey")]
    pub tip_set_key: TipSetKey,
    #[serde(rename = "msgCid")]
    pub msg_cid: Cid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertType {
    pub system: String,
    pub subsystem: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Zone {
    pub name: String,
    pub offset: i32,
    pub is_dst: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ZoneTrans {
    pub when: i64,
    pub index: u8,
    pub isstd: bool,
    pub isutc: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Location {
    pub name: String,
    pub zone: Vec<Zone>,
    pub tx: Vec<ZoneTrans>,
    pub extend: String,
    pub cache_start: i64,
    pub cache_end: i64,
    pub cache_zone: Option<Zone>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Time {
    pub wall: u64,
    pub ext: i64,
    pub loc: Option<Location>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertEvent {
    #[serde(rename = "type")]
    pub type_: String,
    pub message: Vec<u8>,
    pub time: Time,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventType {
    pub system: String,
    pub event: String,
    pub enabled: bool,
    pub safe: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Alert {
    #[serde(rename = "type")]
    pub type_: AlertType,
    pub active: bool,
    pub last_active: Option<AlertEvent>,
    pub last_resolved: Option<AlertEvent>,
    pub journal_type: EventType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockTemplate {
    pub miner: String,
    pub parents: TipSetKey,
    pub ticket: Option<Ticket>,
    pub eproof: Option<ElectionProof>,
    pub beacon_values: Vec<BeaconEntry>,
    pub messages: Vec<Option<SignedMessage>>,
    pub epoch: i64,
    pub timestamp: u64,
    pub winning_po_st_proof: Vec<PoStProof>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockMsg {
    pub header: Option<BlockHeader>,
    pub bls_messages: Vec<Cid>,
    pub secpk_messages: Vec<Cid>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExtendedSectorInfo {
    pub seal_proof: i64,
    pub sector_number: u64,
    pub sector_key: Option<Cid>,
    pub sealed_cid: Cid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MiningBaseInfo {
    pub miner_power: String,
    pub network_power: String,
    pub sectors: Vec<ExtendedSectorInfo>,
    pub worker_key: String,
    pub sector_size: u64,
    pub prev_beacon_entry: BeaconEntry,
    pub beacon_entries: Vec<BeaconEntry>,
    pub eligible_for_mining: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePrototype {
    pub message: Message,
    pub valid_nonce: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckStatus {
    pub code: i32,
    pub ok: bool,
    pub err: String,
    pub hint: HashMap<String, Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageCheckStatus {
    pub cid: Cid,
    pub check_status: CheckStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MpoolConfig {
    pub priority_addrs: Vec<String>,
    pub size_limit_high: i32,
    pub size_limit_low: i32,
    pub replace_by_fee_ratio: i64,
    pub prune_cooldown: i64,
    pub gas_limit_overestimation: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MpoolUpdate {
    #[serde(rename = "type")]
    pub type_: i32,
    pub message: Option<SignedMessage>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MsigTransaction {
    pub id: i64,
    pub to: String,
    pub value: String,
    pub method: u64,
    pub params: Vec<u8>,
    pub approved: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MsigVesting {
    pub initial_balance: String,
    pub start_epoch: i64,
    pub unlock_duration: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddrInfo {
    pub id: String,
    pub addrs: Vec<Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NatInfo {
    pub reachability: i32,
    pub public_addrs: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Stats {
    pub total_in: i64,
    pub total_out: i64,
    pub rate_in: f64,
    pub rate_out: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetBlockList {
    pub peers: Vec<String>,
    pub ip_addrs: Vec<String>,
    pub ip_subnets: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetLimit {
    #[serde(rename = "")]
    pub memory: i64,
    pub streams: i32,
    pub streams_inbound: i32,
    pub streams_outbound: i32,
    pub conns: i32,
    pub conns_inbound: i32,
    pub conns_outbound: i32,
    pub fd: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnMgrInfo {
    pub first_seen: Time,
    pub value: i32,
    pub tags: HashMap<String, i32>,
    pub conns: HashMap<String, Time>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExtendedPeerInfo {
    pub id: String,
    pub agent: String,
    pub addrs: Vec<String>,
    pub protocols: Vec<String>,
    pub conn_mgr_meta: Option<ConnMgrInfo>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopicScoreSnapshot {
    pub time_in_mesh: i64,
    pub first_message_deliveries: f64,
    pub mesh_message_deliveries: f64,
    pub invalid_message_deliveries: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PeerScoreSnapshot {
    pub score: f64,
    pub topics: HashMap<String, Option<TopicScoreSnapshot>>,
    pub app_specific_score: f64,
    pub ip_colocation_factor: f64,
    pub behaviour_penalty: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PubsubScore {
    pub id: String,
    pub score: Option<PeerScoreSnapshot>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScopeStat {
    pub num_streams_inbound: i32,
    pub num_streams_outbound: i32,
    pub num_conns_inbound: i32,
    pub num_conns_outbound: i32,
    pub num_fd: i32,
    pub memory: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetStat {
    #[serde(rename = "")]
    pub system: Option<ScopeStat>,
    #[serde(rename = "")]
    pub transient: Option<ScopeStat>,
    #[serde(rename = "")]
    pub services: HashMap<String, ScopeStat>,
    #[serde(rename = "")]
    pub protocols: HashMap<String, ScopeStat>,
    #[serde(rename = "")]
    pub peers: HashMap<String, ScopeStat>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NodeSyncStatus {
    pub epoch: u64,
    pub behind: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NodePeerStatus {
    pub peers_to_publish_msgs: i32,
    pub peers_to_publish_blocks: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NodeChainStatus {
    pub blocks_per_tipset_last100: f64,
    pub blocks_per_tipset_last_finality: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NodeStatus {
    pub sync_status: NodeSyncStatus,
    pub peer_status: NodePeerStatus,
    pub chain_status: NodeChainStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChannelAvailableFunds {
    pub channel: Option<String>,
    pub from: String,
    pub to: String,
    pub confirmed_amt: String,
    pub pending_amt: String,
    pub non_reserved_amt: String,
    pub pending_available_amt: String,
    pub pending_wait_sentinel: Option<Cid>,
    pub queued_amt: String,
    pub voucher_reedeemed_amt: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChannelInfo {
    pub channel: String,
    pub wait_sentinel: Cid,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaychGetOpts {
    pub off_chain: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModVerifyParams {
    pub actor: String,
    pub method: u64,
    pub data: Vec<u8>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoucherSpec {
    pub amount: String,
    pub time_lock_min: i64,
    pub time_lock_max: i64,
    pub min_settle: i64,
    pub extra: Option<ModVerifyParams>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Merge {
    pub lane: u64,
    pub nonce: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SignedVoucher {
    pub channel_addr: String,
    pub time_lock_min: i64,
    pub time_lock_max: i64,
    pub secret_hash: Vec<u8>,
    pub extra: Option<ModVerifyParams>,
    pub lane: u64,
    pub nonce: u64,
    pub amount: String,
    pub min_settle_height: i64,
    pub merges: Vec<Merge>,
    pub signature: Option<Signature>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentInfo {
    pub channel: String,
    pub wait_sentinel: Cid,
    pub vouchers: Vec<Option<SignedVoucher>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaychStatus {
    pub control_addr: String,
    pub direction: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoucherCreateResult {
    pub voucher: Option<SignedVoucher>,
    pub shortfall: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Fault {
    pub miner: String,
    pub epoch: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MsgGasCost {
    pub message: Cid,
    pub gas_used: String,
    pub base_fee_burn: String,
    pub over_estimation_burn: String,
    pub miner_penalty: String,
    pub miner_tip: String,
    pub refund: String,
    pub total_cost: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageTrace {
    pub from: String,
    pub to: String,
    pub value: String,
    pub method: u64,
    pub params: Vec<u8>,
    pub params_codec: u64,
    pub gas_limit: u64,
    pub read_only: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReturnTrace {
    pub exit_code: i64,
    #[serde(rename = "return")]
    pub return_: Vec<u8>,
    pub return_codec: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorV5 {
    pub code: Cid,
    pub head: Cid,
    pub nonce: u64,
    pub balance: String,
    pub delegated_address: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorTrace {
    pub id: u64,
    pub state: ActorV5,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GasTrace {
    pub name: String,
    #[serde(rename = "tg")]
    pub total_gas: i64,
    #[serde(rename = "cg")]
    pub compute_gas: i64,
    #[serde(rename = "sg")]
    pub storage_gas: i64,
    #[serde(rename = "tt")]
    pub time_taken: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionTrace {
    pub msg: MessageTrace,
    pub msg_rct: ReturnTrace,
    #[serde(rename = "")]
    pub invoked_actor: Option<ActorTrace>,
    pub gas_charges: Vec<Option<GasTrace>>,
    pub subcalls: Vec<ExecutionTrace>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InvocResult {
    pub msg_cid: Cid,
    pub msg: Option<Message>,
    pub msg_rct: Option<MessageReceipt>,
    pub gas_cost: MsgGasCost,
    pub execution_trace: ExecutionTrace,
    pub error: String,
    pub duration: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComputeStateOutput {
    pub root: Cid,
    pub trace: Vec<Option<InvocResult>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DealCollateralBounds {
    pub min: String,
    pub max: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Allocation {
    pub client: u64,
    pub provider: u64,
    pub data: Cid,
    pub size: u64,
    pub term_min: i64,
    pub term_max: i64,
    pub expiration: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Claim {
    pub provider: u64,
    pub client: u64,
    pub data: Cid,
    pub size: u64,
    pub term_min: i64,
    pub term_max: i64,
    pub term_start: i64,
    pub sector: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ForkUpgradeParams {
    pub upgrade_smoke_height: i64,
    pub upgrade_breeze_height: i64,
    pub upgrade_ignition_height: i64,
    pub upgrade_liftoff_height: i64,
    pub upgrade_assembly_height: i64,
    pub upgrade_refuel_height: i64,
    pub upgrade_tape_height: i64,
    pub upgrade_kumquat_height: i64,
    pub breeze_gas_tamping_duration: i64,
    pub upgrade_calico_height: i64,
    pub upgrade_persian_height: i64,
    pub upgrade_orange_height: i64,
    pub upgrade_claus_height: i64,
    pub upgrade_trust_height: i64,
    pub upgrade_norwegian_height: i64,
    pub upgrade_turbo_height: i64,
    pub upgrade_hyperdrive_height: i64,
    pub upgrade_chocolate_height: i64,
    pub upgrade_oh_snap_height: i64,
    pub upgrade_skyr_height: i64,
    pub upgrade_shark_height: i64,
    pub upgrade_hygge_height: i64,
    pub upgrade_lightning_height: i64,
    pub upgrade_thunder_height: i64,
    pub upgrade_watermelon_height: i64,
    pub upgrade_dragon_height: i64,
    pub upgrade_phoenix_height: i64,
    pub upgrade_waffle_height: i64,
    pub upgrade_tuktuk_height: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkParams {
    pub network_name: String,
    pub block_delay_secs: u64,
    pub consensus_miner_min_power: String,
    pub supported_proof_types: Vec<i64>,
    pub pre_commit_challenge_delay: i64,
    pub fork_upgrade_params: ForkUpgradeParams,
    pub eip155_chain_id: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageMatch {
    pub to: String,
    pub from: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketBalance {
    pub escrow: String,
    pub locked: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DealLabel {
    pub bs: Vec<u8>,
    pub not_string: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DealProposal {
    pub piece_cid: Cid,
    pub piece_size: u64,
    pub verified_deal: bool,
    pub client: String,
    pub provider: String,
    pub label: DealLabel,
    pub start_epoch: i64,
    pub end_epoch: i64,
    pub storage_price_per_epoch: String,
    pub provider_collateral: String,
    pub client_collateral: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketDealState {
    pub sector_number: u64,
    pub sector_start_epoch: i64,
    pub last_updated_epoch: i64,
    pub slash_epoch: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketDeal {
    pub proposal: DealProposal,
    pub state: MarketDealState,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorOnChainInfo {
    pub sector_number: u64,
    pub seal_proof: i64,
    pub sealed_cid: Cid,
    pub deal_i_ds: Vec<u64>,
    pub activation: i64,
    pub expiration: i64,
    pub deal_weight: String,
    pub verified_deal_weight: String,
    pub initial_pledge: String,
    pub expected_day_reward: String,
    pub expected_storage_pledge: String,
    pub power_base_epoch: i64,
    pub replaced_day_reward: String,
    pub sector_key_cid: Option<Cid>,
    pub flags: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Deadline {
    pub post_submissions: BitField,
    pub disputable_proof_count: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BeneficiaryTerm {
    pub quota: String,
    pub used_quota: String,
    pub expiration: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PendingBeneficiaryChange {
    pub new_beneficiary: String,
    pub new_quota: String,
    pub new_expiration: i64,
    pub approved_by_beneficiary: bool,
    pub approved_by_nominee: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MinerInfo {
    pub owner: String,
    pub worker: String,
    pub new_worker: String,
    pub control_addresses: Vec<String>,
    pub worker_change_epoch: i64,
    pub peer_id: Option<String>,
    pub multiaddrs: Vec<Vec<u8>>,
    pub window_po_st_proof_type: i64,
    pub sector_size: u64,
    pub window_po_st_partition_sectors: u64,
    pub consensus_fault_elapsed: i64,
    pub pending_owner_address: Option<String>,
    pub beneficiary: String,
    pub beneficiary_term: Option<BeneficiaryTerm>,
    pub pending_beneficiary_term: Option<PendingBeneficiaryChange>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorPreCommitInfo {
    pub seal_proof: i64,
    pub sector_number: u64,
    pub sealed_cid: Cid,
    pub seal_rand_epoch: i64,
    pub deal_i_ds: Vec<u64>,
    pub expiration: i64,
    pub unsealed_cid: Option<Cid>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Partition {
    pub all_sectors: BitField,
    pub faulty_sectors: BitField,
    pub recovering_sectors: BitField,
    pub live_sectors: BitField,
    pub active_sectors: BitField,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Claim1 {
    pub raw_byte_power: String,
    pub quality_adj_power: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MinerPower {
    pub miner_power: Claim,
    pub total_power: Claim,
    pub has_min_power: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Info {
    pub current_epoch: i64,
    pub period_start: i64,
    pub index: u64,
    pub open: i64,
    pub close: i64,
    pub challenge: i64,
    pub fault_cutoff: i64,
    pub w_po_st_period_deadlines: u64,
    pub w_po_st_proving_period: i64,
    pub w_po_st_challenge_window: i64,
    pub w_po_st_challenge_lookback: i64,
    pub fault_declaration_cutoff: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MinerSectors {
    pub live: u64,
    pub active: u64,
    pub faulty: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorState {
    pub balance: String,
    pub code: Cid,
    pub state: Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MsgLookup {
    pub message: Cid,
    pub receipt: MessageReceipt,
    pub return_dec: Value,
    pub tip_set: TipSetKey,
    pub height: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorExpiration {
    pub on_time: i64,
    pub early: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorLocation {
    pub deadline: u64,
    pub partition: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectorPreCommitOnChainInfo {
    pub info: SectorPreCommitInfo,
    pub pre_commit_deposit: String,
    pub pre_commit_epoch: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CirculatingSupply {
    pub fil_vested: String,
    pub fil_mined: String,
    pub fil_burnt: String,
    pub fil_locked: String,
    pub fil_circulating: String,
    pub fil_reserve_disbursed: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActiveSync {
    pub worker_id: u64,
    pub base: Option<TipSet>,
    pub target: Option<TipSet>,
    pub stage: i32,
    pub height: i64,
    pub start: Time,
    pub end: Time,
    pub message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncState {
    pub active_syncs: Vec<ActiveSync>,
    pub vm_applied: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct APIVersion {
    pub version: String,
    pub api_version: u32,
    pub block_delay: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyInfo {
    #[serde(rename = "type")]
    pub type_: String,
    pub private_key: Vec<u8>,
}

#[async_trait::async_trait]
pub trait FullNodeApi {
    async fn auth_new(&self, permissions: Vec<String>) -> Result<Vec<u8>, Error>;
    async fn auth_verify(&self, string: String) -> Result<Vec<String>, Error>;
    async fn chain_blockstore_info(&self) -> Result<HashMap<String, Value>, Error>;
    async fn chain_check_blockstore(&self) -> Result<(), Error>;
    async fn chain_delete_obj(&self, cid: Cid) -> Result<(), Error>;
    async fn chain_export(&self, chain_epoch: i64, bool: bool, tip_set_key: Option<TipSetKey>) -> Result<mpsc::Receiver<Vec<u8>>, Error>;
    async fn chain_export_range_internal(&self, tip_set_key: Option<TipSetKey>, tip_set_key1: Option<TipSetKey>, chain_export_config: ChainExportConfig) -> Result<(), Error>;
    async fn chain_get_block(&self, cid: Cid) -> Result<Option<BlockHeader>, Error>;
    async fn chain_get_block_messages(&self, cid: Cid) -> Result<Option<BlockMessages>, Error>;
    async fn chain_get_events(&self, cid: Cid) -> Result<Vec<Event>, Error>;
    async fn chain_get_genesis(&self) -> Result<Option<TipSet>, Error>;
    async fn chain_get_message(&self, cid: Cid) -> Result<Option<Message>, Error>;
    async fn chain_get_messages_in_tipset(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<Message>, Error>;
    async fn chain_get_node(&self, string: String) -> Result<Option<IpldObject>, Error>;
    async fn chain_get_parent_messages(&self, cid: Cid) -> Result<Vec<Message>, Error>;
    async fn chain_get_parent_receipts(&self, cid: Cid) -> Result<Vec<Option<MessageReceipt>>, Error>;
    async fn chain_get_path(&self, tip_set_key: Option<TipSetKey>, tip_set_key1: Option<TipSetKey>) -> Result<Vec<Option<HeadChange>>, Error>;
    async fn chain_get_tip_set(&self, tip_set_key: Option<TipSetKey>) -> Result<Option<TipSet>, Error>;
    async fn chain_get_tip_set_after_height(&self, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<Option<TipSet>, Error>;
    async fn chain_get_tip_set_by_height(&self, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<Option<TipSet>, Error>;
    async fn chain_has_obj(&self, cid: Cid) -> Result<bool, Error>;
    async fn chain_head(&self) -> Result<Option<TipSet>, Error>;
    async fn chain_hot_gc(&self, hot_gc_opts: HotGCOpts) -> Result<(), Error>;
    async fn chain_notify(&self) -> Result<mpsc::Receiver<Vec<Option<HeadChange>>>, Error>;
    async fn chain_prune(&self, prune_opts: PruneOpts) -> Result<(), Error>;
    async fn chain_put_obj(&self, block: Value) -> Result<(), Error>;
    async fn chain_read_obj(&self, cid: Cid) -> Result<Vec<u8>, Error>;
    async fn chain_set_head(&self, tip_set_key: Option<TipSetKey>) -> Result<(), Error>;
    async fn chain_stat_obj(&self, cid: Cid, cid1: Cid) -> Result<ObjStat, Error>;
    async fn chain_tip_set_weight(&self, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn closing(&self) -> Result<mpsc::Receiver<()>, Error>;
    async fn create_backup(&self, string: String) -> Result<(), Error>;
    async fn discover(&self) -> Result<HashMap<String, Value>, Error>;
    async fn eth_accounts(&self) -> Result<Vec<[u8; 20]>, Error>;
    async fn eth_address_to_filecoin_address(&self, eth_address: [u8; 20]) -> Result<String, Error>;
    async fn eth_block_number(&self) -> Result<u64, Error>;
    async fn eth_call(&self, eth_call: EthCall, eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<u8>, Error>;
    async fn eth_chain_id(&self) -> Result<u64, Error>;
    async fn eth_estimate_gas(&self, uint8s: Vec<u8>) -> Result<u64, Error>;
    async fn eth_fee_history(&self, uint8s: Vec<u8>) -> Result<EthFeeHistory, Error>;
    async fn eth_gas_price(&self) -> Result<EthBigInt, Error>;
    async fn eth_get_balance(&self, eth_address: [u8; 20], eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<EthBigInt, Error>;
    async fn eth_get_block_by_hash(&self, eth_hash: [u8; 32], bool: bool) -> Result<EthBlock, Error>;
    async fn eth_get_block_by_number(&self, string: String, bool: bool) -> Result<EthBlock, Error>;
    async fn eth_get_block_receipts(&self, eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<Option<EthTxReceipt>>, Error>;
    async fn eth_get_block_receipts_limited(&self, eth_block_number_or_hash: EthBlockNumberOrHash, chain_epoch: i64) -> Result<Vec<Option<EthTxReceipt>>, Error>;
    async fn eth_get_block_transaction_count_by_hash(&self, eth_hash: [u8; 32]) -> Result<u64, Error>;
    async fn eth_get_block_transaction_count_by_number(&self, eth_uint64: u64) -> Result<u64, Error>;
    async fn eth_get_code(&self, eth_address: [u8; 20], eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<u8>, Error>;
    async fn eth_get_filter_changes(&self, eth_filter_id: [u8; 32]) -> Result<Option<EthFilterResult>, Error>;
    async fn eth_get_filter_logs(&self, eth_filter_id: [u8; 32]) -> Result<Option<EthFilterResult>, Error>;
    async fn eth_get_logs(&self, eth_filter_spec: Option<EthFilterSpec>) -> Result<Option<EthFilterResult>, Error>;
    async fn eth_get_message_cid_by_transaction_hash(&self, eth_hash: Option<[u8; 32]>) -> Result<Option<Cid>, Error>;
    async fn eth_get_storage_at(&self, eth_address: [u8; 20], uint8s: Vec<u8>, eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<u8>, Error>;
    async fn eth_get_transaction_by_block_hash_and_index(&self, eth_hash: [u8; 32], eth_uint64: u64) -> Result<EthTx, Error>;
    async fn eth_get_transaction_by_block_number_and_index(&self, eth_uint64: u64, eth_uint641: u64) -> Result<EthTx, Error>;
    async fn eth_get_transaction_by_hash(&self, eth_hash: Option<[u8; 32]>) -> Result<Option<EthTx>, Error>;
    async fn eth_get_transaction_by_hash_limited(&self, eth_hash: Option<[u8; 32]>, chain_epoch: i64) -> Result<Option<EthTx>, Error>;
    async fn eth_get_transaction_count(&self, eth_address: [u8; 20], eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<u64, Error>;
    async fn eth_get_transaction_hash_by_cid(&self, cid: Cid) -> Result<Option<[u8; 32]>, Error>;
    async fn eth_get_transaction_receipt(&self, eth_hash: [u8; 32]) -> Result<Option<EthTxReceipt>, Error>;
    async fn eth_get_transaction_receipt_limited(&self, eth_hash: [u8; 32], chain_epoch: i64) -> Result<Option<EthTxReceipt>, Error>;
    async fn eth_max_priority_fee_per_gas(&self) -> Result<EthBigInt, Error>;
    async fn eth_new_block_filter(&self) -> Result<[u8; 32], Error>;
    async fn eth_new_filter(&self, eth_filter_spec: Option<EthFilterSpec>) -> Result<[u8; 32], Error>;
    async fn eth_new_pending_transaction_filter(&self) -> Result<[u8; 32], Error>;
    async fn eth_protocol_version(&self) -> Result<u64, Error>;
    async fn eth_send_raw_transaction(&self, uint8s: Vec<u8>) -> Result<[u8; 32], Error>;
    async fn eth_send_raw_transaction_untrusted(&self, uint8s: Vec<u8>) -> Result<[u8; 32], Error>;
    async fn eth_subscribe(&self, uint8s: Vec<u8>) -> Result<[u8; 32], Error>;
    async fn eth_syncing(&self) -> Result<EthSyncingResult, Error>;
    async fn eth_trace_block(&self, string: String) -> Result<Vec<Option<EthTraceBlock>>, Error>;
    async fn eth_trace_filter(&self, eth_trace_filter_criteria: EthTraceFilterCriteria) -> Result<Vec<Option<EthTraceFilterResult>>, Error>;
    async fn eth_trace_replay_block_transactions(&self, string: String, strings: Vec<String>) -> Result<Vec<Option<EthTraceReplayBlockTransaction>>, Error>;
    async fn eth_trace_transaction(&self, string: String) -> Result<Vec<Option<EthTraceTransaction>>, Error>;
    async fn eth_uninstall_filter(&self, eth_filter_id: [u8; 32]) -> Result<bool, Error>;
    async fn eth_unsubscribe(&self, eth_subscription_id: [u8; 32]) -> Result<bool, Error>;
    async fn f3_get_certificate(&self, uint64: u64) -> Result<Option<FinalityCertificate>, Error>;
    async fn f3_get_ec_power_table(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<PowerEntry>, Error>;
    async fn f3_get_f3_power_table(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<PowerEntry>, Error>;
    async fn f3_get_latest_certificate(&self) -> Result<Option<FinalityCertificate>, Error>;
    async fn f3_get_manifest(&self) -> Result<Option<Manifest>, Error>;
    async fn f3_get_or_renew_participation_ticket(&self, address: String, uint8s: Vec<u8>, uint64: u64) -> Result<Vec<u8>, Error>;
    async fn f3_get_progress(&self) -> Result<Instant, Error>;
    async fn f3_is_running(&self) -> Result<bool, Error>;
    async fn f3_list_participants(&self) -> Result<Vec<F3Participant>, Error>;
    async fn f3_participate(&self, uint8s: Vec<u8>) -> Result<F3ParticipationLease, Error>;
    async fn filecoin_address_to_eth_address(&self, uint8s: Vec<u8>) -> Result<[u8; 20], Error>;
    async fn gas_estimate_fee_cap(&self, message: Option<Message>, int64: i64, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn gas_estimate_gas_limit(&self, message: Option<Message>, tip_set_key: Option<TipSetKey>) -> Result<i64, Error>;
    async fn gas_estimate_gas_premium(&self, uint64: u64, address: String, int64: i64, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn gas_estimate_message_gas(&self, message: Option<Message>, message_send_spec: Option<MessageSendSpec>, tip_set_key: Option<TipSetKey>) -> Result<Option<Message>, Error>;
    async fn get_actor_events_raw(&self, actor_event_filter: Option<ActorEventFilter>) -> Result<Vec<Option<ActorEvent>>, Error>;
    async fn id(&self) -> Result<String, Error>;
    async fn log_alerts(&self) -> Result<Vec<Alert>, Error>;
    async fn log_list(&self) -> Result<Vec<String>, Error>;
    async fn log_set_level(&self, string: String, string1: String) -> Result<(), Error>;
    async fn market_add_balance(&self, address: String, address1: String, int: String) -> Result<Cid, Error>;
    async fn market_get_reserved(&self, address: String) -> Result<String, Error>;
    async fn market_release_funds(&self, address: String, int: String) -> Result<(), Error>;
    async fn market_reserve_funds(&self, address: String, address1: String, int: String) -> Result<Cid, Error>;
    async fn market_withdraw(&self, address: String, address1: String, int: String) -> Result<Cid, Error>;
    async fn miner_create_block(&self, block_template: Option<BlockTemplate>) -> Result<Option<BlockMsg>, Error>;
    async fn miner_get_base_info(&self, address: String, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<Option<MiningBaseInfo>, Error>;
    async fn mpool_batch_push(&self, s: Vec<Option<SignedMessage>>) -> Result<Vec<Cid>, Error>;
    async fn mpool_batch_push_message(&self, s: Vec<Option<Message>>, message_send_spec: Option<MessageSendSpec>) -> Result<Vec<Option<SignedMessage>>, Error>;
    async fn mpool_batch_push_untrusted(&self, s: Vec<Option<SignedMessage>>) -> Result<Vec<Cid>, Error>;
    async fn mpool_check_messages(&self, s: Vec<Option<MessagePrototype>>) -> Result<Vec<Vec<MessageCheckStatus>>, Error>;
    async fn mpool_check_pending_messages(&self, address: String) -> Result<Vec<Vec<MessageCheckStatus>>, Error>;
    async fn mpool_check_replace_messages(&self, s: Vec<Option<Message>>) -> Result<Vec<Vec<MessageCheckStatus>>, Error>;
    async fn mpool_clear(&self, bool: bool) -> Result<(), Error>;
    async fn mpool_get_config(&self) -> Result<Option<MpoolConfig>, Error>;
    async fn mpool_get_nonce(&self, address: String) -> Result<u64, Error>;
    async fn mpool_pending(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<Option<SignedMessage>>, Error>;
    async fn mpool_push(&self, signed_message: Option<SignedMessage>) -> Result<Cid, Error>;
    async fn mpool_push_message(&self, message: Option<Message>, message_send_spec: Option<MessageSendSpec>) -> Result<Option<SignedMessage>, Error>;
    async fn mpool_push_untrusted(&self, signed_message: Option<SignedMessage>) -> Result<Cid, Error>;
    async fn mpool_select(&self, tip_set_key: Option<TipSetKey>, float64: f64) -> Result<Vec<Option<SignedMessage>>, Error>;
    async fn mpool_set_config(&self, mpool_config: Option<MpoolConfig>) -> Result<(), Error>;
    async fn mpool_sub(&self) -> Result<mpsc::Receiver<MpoolUpdate>, Error>;
    async fn msig_add_approve(&self, address: String, address1: String, uint64: u64, address2: String, address3: String, bool: bool) -> Result<Option<MessagePrototype>, Error>;
    async fn msig_add_cancel(&self, address: String, address1: String, uint64: u64, address2: String, bool: bool) -> Result<Option<MessagePrototype>, Error>;
    async fn msig_add_propose(&self, address: String, address1: String, address2: String, bool: bool) -> Result<Option<MessagePrototype>, Error>;
    async fn msig_approve(&self, address: String, uint64: u64, address1: String) -> Result<Option<MessagePrototype>, Error>;
    async fn msig_approve_txn_hash(&self, address: String, uint64: u64, address1: String, address2: String, int: String, address3: String, uint641: u64, uint8s: Vec<u8>) -> Result<Option<MessagePrototype>, Error>;
    async fn msig_cancel(&self, address: String, uint64: u64, address1: String) -> Result<Option<MessagePrototype>, Error>;
    async fn msig_cancel_txn_hash(&self, address: String, uint64: u64, address1: String, int: String, address2: String, uint641: u64, uint8s: Vec<u8>) -> Result<Option<MessagePrototype>, Error>;
    async fn msig_create(&self, uint64: u64, addresss: Vec<String>, chain_epoch: i64, int: String, address: String, int1: String) -> Result<Option<MessagePrototype>, Error>;
    async fn msig_get_available_balance(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn msig_get_pending(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Vec<Option<MsigTransaction>>, Error>;
    async fn msig_get_vested(&self, address: String, tip_set_key: Option<TipSetKey>, tip_set_key1: Option<TipSetKey>) -> Result<String, Error>;
    async fn msig_get_vesting_schedule(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MsigVesting, Error>;
    async fn msig_propose(&self, address: String, address1: String, int: String, address2: String, uint64: u64, uint8s: Vec<u8>) -> Result<Option<MessagePrototype>, Error>;
    async fn msig_remove_signer(&self, address: String, address1: String, address2: String, bool: bool) -> Result<Option<MessagePrototype>, Error>;
    async fn msig_swap_approve(&self, address: String, address1: String, uint64: u64, address2: String, address3: String, address4: String) -> Result<Option<MessagePrototype>, Error>;
    async fn msig_swap_cancel(&self, address: String, address1: String, uint64: u64, address2: String, address3: String) -> Result<Option<MessagePrototype>, Error>;
    async fn msig_swap_propose(&self, address: String, address1: String, address2: String, address3: String) -> Result<Option<MessagePrototype>, Error>;
    async fn net_addrs_listen(&self) -> Result<AddrInfo, Error>;
    async fn net_agent_version(&self, id: String) -> Result<String, Error>;
    async fn net_auto_nat_status(&self) -> Result<NatInfo, Error>;
    async fn net_bandwidth_stats(&self) -> Result<Stats, Error>;
    async fn net_bandwidth_stats_by_peer(&self) -> Result<HashMap<String, Stats>, Error>;
    async fn net_bandwidth_stats_by_protocol(&self) -> Result<HashMap<String, Stats>, Error>;
    async fn net_block_add(&self, net_block_list: NetBlockList) -> Result<(), Error>;
    async fn net_block_list(&self) -> Result<NetBlockList, Error>;
    async fn net_block_remove(&self, net_block_list: NetBlockList) -> Result<(), Error>;
    async fn net_connect(&self, addr_info: AddrInfo) -> Result<(), Error>;
    async fn net_connectedness(&self, id: String) -> Result<i32, Error>;
    async fn net_disconnect(&self, id: String) -> Result<(), Error>;
    async fn net_find_peer(&self, id: String) -> Result<AddrInfo, Error>;
    async fn net_limit(&self, string: String) -> Result<NetLimit, Error>;
    async fn net_listening(&self) -> Result<bool, Error>;
    async fn net_peer_info(&self, id: String) -> Result<Option<ExtendedPeerInfo>, Error>;
    async fn net_peers(&self) -> Result<Vec<AddrInfo>, Error>;
    async fn net_ping(&self, id: String) -> Result<i64, Error>;
    async fn net_protect_add(&self, ids: Vec<String>) -> Result<(), Error>;
    async fn net_protect_list(&self) -> Result<Vec<String>, Error>;
    async fn net_protect_remove(&self, ids: Vec<String>) -> Result<(), Error>;
    async fn net_pubsub_scores(&self) -> Result<Vec<PubsubScore>, Error>;
    async fn net_set_limit(&self, string: String, net_limit: NetLimit) -> Result<(), Error>;
    async fn net_stat(&self, string: String) -> Result<NetStat, Error>;
    async fn net_version(&self) -> Result<String, Error>;
    async fn node_status(&self, bool: bool) -> Result<NodeStatus, Error>;
    async fn paych_allocate_lane(&self, address: String) -> Result<u64, Error>;
    async fn paych_available_funds(&self, address: String) -> Result<Option<ChannelAvailableFunds>, Error>;
    async fn paych_available_funds_by_from_to(&self, address: String, address1: String) -> Result<Option<ChannelAvailableFunds>, Error>;
    async fn paych_collect(&self, address: String) -> Result<Cid, Error>;
    async fn paych_fund(&self, address: String, address1: String, int: String) -> Result<Option<ChannelInfo>, Error>;
    async fn paych_get(&self, address: String, address1: String, int: String, paych_get_opts: PaychGetOpts) -> Result<Option<ChannelInfo>, Error>;
    async fn paych_get_wait_ready(&self, cid: Cid) -> Result<String, Error>;
    async fn paych_list(&self) -> Result<Vec<String>, Error>;
    async fn paych_new_payment(&self, address: String, address1: String, voucher_specs: Vec<VoucherSpec>) -> Result<Option<PaymentInfo>, Error>;
    async fn paych_settle(&self, address: String) -> Result<Cid, Error>;
    async fn paych_status(&self, address: String) -> Result<Option<PaychStatus>, Error>;
    async fn paych_voucher_add(&self, address: String, signed_voucher: Option<SignedVoucher>, uint8s: Vec<u8>, int: String) -> Result<String, Error>;
    async fn paych_voucher_check_spendable(&self, address: String, signed_voucher: Option<SignedVoucher>, uint8s: Vec<u8>, uint8s1: Vec<u8>) -> Result<bool, Error>;
    async fn paych_voucher_check_valid(&self, address: String, signed_voucher: Option<SignedVoucher>) -> Result<(), Error>;
    async fn paych_voucher_create(&self, address: String, int: String, uint64: u64) -> Result<Option<VoucherCreateResult>, Error>;
    async fn paych_voucher_list(&self, address: String) -> Result<Vec<Option<SignedVoucher>>, Error>;
    async fn paych_voucher_submit(&self, address: String, signed_voucher: Option<SignedVoucher>, uint8s: Vec<u8>, uint8s1: Vec<u8>) -> Result<Cid, Error>;
    async fn session(&self) -> Result<[u8; 16], Error>;
    async fn shutdown(&self) -> Result<(), Error>;
    async fn start_time(&self) -> Result<Time, Error>;
    async fn state_account_key(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_actor_code_ci_ds(&self, version: u32) -> Result<HashMap<String, Cid>, Error>;
    async fn state_actor_manifest_cid(&self, version: u32) -> Result<Cid, Error>;
    async fn state_all_miner_faults(&self, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<Vec<Option<Fault>>, Error>;
    async fn state_call(&self, message: Option<Message>, tip_set_key: Option<TipSetKey>) -> Result<Option<InvocResult>, Error>;
    async fn state_changed_actors(&self, cid: Cid, cid1: Cid) -> Result<HashMap<String, ActorV5>, Error>;
    async fn state_circulating_supply(&self, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_compute(&self, chain_epoch: i64, s: Vec<Option<Message>>, tip_set_key: Option<TipSetKey>) -> Result<Option<ComputeStateOutput>, Error>;
    async fn state_compute_data_cid(&self, address: String, registered_seal_proof: i64, deal_ids: Vec<u64>, tip_set_key: Option<TipSetKey>) -> Result<Cid, Error>;
    async fn state_deal_provider_collateral_bounds(&self, padded_piece_size: u64, bool: bool, tip_set_key: Option<TipSetKey>) -> Result<DealCollateralBounds, Error>;
    async fn state_decode_params(&self, address: String, method_num: u64, uint8s: Vec<u8>, tip_set_key: Option<TipSetKey>) -> Result<Value, Error>;
    async fn state_encode_params(&self, cid: Cid, method_num: u64, uint8s: Vec<u8>) -> Result<Vec<u8>, Error>;
    async fn state_get_actor(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<ActorV5>, Error>;
    async fn state_get_all_allocations(&self, tip_set_key: Option<TipSetKey>) -> Result<HashMap<u64, Allocation>, Error>;
    async fn state_get_all_claims(&self, tip_set_key: Option<TipSetKey>) -> Result<HashMap<u64, Claim>, Error>;
    async fn state_get_allocation(&self, address: String, allocation_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<Allocation>, Error>;
    async fn state_get_allocation_for_pending_deal(&self, deal_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<Allocation>, Error>;
    async fn state_get_allocation_id_for_pending_deal(&self, deal_id: u64, tip_set_key: Option<TipSetKey>) -> Result<u64, Error>;
    async fn state_get_allocations(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<HashMap<u64, Allocation>, Error>;
    async fn state_get_beacon_entry(&self, chain_epoch: i64) -> Result<Option<BeaconEntry>, Error>;
    async fn state_get_claim(&self, address: String, claim_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<Claim>, Error>;
    async fn state_get_claims(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<HashMap<u64, Claim>, Error>;
    async fn state_get_network_params(&self) -> Result<Option<NetworkParams>, Error>;
    async fn state_get_randomness_digest_from_beacon(&self, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_get_randomness_digest_from_tickets(&self, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_get_randomness_from_beacon(&self, domain_separation_tag: i64, chain_epoch: i64, uint8s: Vec<u8>, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_get_randomness_from_tickets(&self, domain_separation_tag: i64, chain_epoch: i64, uint8s: Vec<u8>, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_list_actors(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<String>, Error>;
    async fn state_list_messages(&self, message_match: Option<MessageMatch>, tip_set_key: Option<TipSetKey>, chain_epoch: i64) -> Result<Vec<Cid>, Error>;
    async fn state_list_miners(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<String>, Error>;
    async fn state_lookup_id(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_lookup_robust_address(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_market_balance(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MarketBalance, Error>;
    async fn state_market_deals(&self, tip_set_key: Option<TipSetKey>) -> Result<HashMap<String, Option<MarketDeal>>, Error>;
    async fn state_market_participants(&self, tip_set_key: Option<TipSetKey>) -> Result<HashMap<String, MarketBalance>, Error>;
    async fn state_market_storage_deal(&self, deal_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<MarketDeal>, Error>;
    async fn state_miner_active_sectors(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Vec<Option<SectorOnChainInfo>>, Error>;
    async fn state_miner_allocated(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<BitField>, Error>;
    async fn state_miner_available_balance(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_miner_deadlines(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Vec<Deadline>, Error>;
    async fn state_miner_faults(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<BitField, Error>;
    async fn state_miner_info(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MinerInfo, Error>;
    async fn state_miner_initial_pledge_collateral(&self, address: String, sector_pre_commit_info: SectorPreCommitInfo, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_miner_initial_pledge_for_sector(&self, chain_epoch: i64, sector_size: u64, uint64: u64, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_miner_partitions(&self, address: String, uint64: u64, tip_set_key: Option<TipSetKey>) -> Result<Vec<Partition>, Error>;
    async fn state_miner_power(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<MinerPower>, Error>;
    async fn state_miner_pre_commit_deposit_for_power(&self, address: String, sector_pre_commit_info: SectorPreCommitInfo, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_miner_proving_deadline(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<Info>, Error>;
    async fn state_miner_recoveries(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<BitField, Error>;
    async fn state_miner_sector_allocated(&self, address: String, sector_number: u64, tip_set_key: Option<TipSetKey>) -> Result<bool, Error>;
    async fn state_miner_sector_count(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MinerSectors, Error>;
    async fn state_miner_sectors(&self, address: String, bit_field: Option<BitField>, tip_set_key: Option<TipSetKey>) -> Result<Vec<Option<SectorOnChainInfo>>, Error>;
    async fn state_network_name(&self) -> Result<String, Error>;
    async fn state_network_version(&self, tip_set_key: Option<TipSetKey>) -> Result<u32, Error>;
    async fn state_read_state(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<ActorState>, Error>;
    async fn state_replay(&self, tip_set_key: Option<TipSetKey>, cid: Cid) -> Result<Option<InvocResult>, Error>;
    async fn state_search_msg(&self, tip_set_key: Option<TipSetKey>, cid: Cid, chain_epoch: i64, bool: bool) -> Result<Option<MsgLookup>, Error>;
    async fn state_sector_expiration(&self, address: String, sector_number: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<SectorExpiration>, Error>;
    async fn state_sector_get_info(&self, address: String, sector_number: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<SectorOnChainInfo>, Error>;
    async fn state_sector_partition(&self, address: String, sector_number: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<SectorLocation>, Error>;
    async fn state_sector_pre_commit_info(&self, address: String, sector_number: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<SectorPreCommitOnChainInfo>, Error>;
    async fn state_vm_circulating_supply_internal(&self, tip_set_key: Option<TipSetKey>) -> Result<CirculatingSupply, Error>;
    async fn state_verified_client_status(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<String>, Error>;
    async fn state_verified_registry_root_key(&self, tip_set_key: Option<TipSetKey>) -> Result<String, Error>;
    async fn state_verifier_status(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<String>, Error>;
    async fn state_wait_msg(&self, cid: Cid, uint64: u64, chain_epoch: i64, bool: bool) -> Result<Option<MsgLookup>, Error>;
    async fn subscribe_actor_events_raw(&self, actor_event_filter: Option<ActorEventFilter>) -> Result<mpsc::Receiver<Option<ActorEvent>>, Error>;
    async fn sync_check_bad(&self, cid: Cid) -> Result<String, Error>;
    async fn sync_checkpoint(&self, tip_set_key: Option<TipSetKey>) -> Result<(), Error>;
    async fn sync_incoming_blocks(&self) -> Result<mpsc::Receiver<Option<BlockHeader>>, Error>;
    async fn sync_mark_bad(&self, cid: Cid) -> Result<(), Error>;
    async fn sync_state(&self) -> Result<Option<SyncState>, Error>;
    async fn sync_submit_block(&self, block_msg: Option<BlockMsg>) -> Result<(), Error>;
    async fn sync_unmark_all_bad(&self) -> Result<(), Error>;
    async fn sync_unmark_bad(&self, cid: Cid) -> Result<(), Error>;
    async fn sync_validate_tipset(&self, tip_set_key: Option<TipSetKey>) -> Result<bool, Error>;
    async fn version(&self) -> Result<APIVersion, Error>;
    async fn wallet_balance(&self, address: String) -> Result<String, Error>;
    async fn wallet_default_address(&self) -> Result<String, Error>;
    async fn wallet_delete(&self, address: String) -> Result<(), Error>;
    async fn wallet_export(&self, address: String) -> Result<Option<KeyInfo>, Error>;
    async fn wallet_has(&self, address: String) -> Result<bool, Error>;
    async fn wallet_import(&self, key_info: Option<KeyInfo>) -> Result<String, Error>;
    async fn wallet_list(&self) -> Result<Vec<String>, Error>;
    async fn wallet_new(&self, key_type: String) -> Result<String, Error>;
    async fn wallet_set_default(&self, address: String) -> Result<(), Error>;
    async fn wallet_sign(&self, address: String, uint8s: Vec<u8>) -> Result<Option<Signature>, Error>;
    async fn wallet_sign_message(&self, address: String, message: Option<Message>) -> Result<Option<SignedMessage>, Error>;
    async fn wallet_validate_address(&self, string: String) -> Result<String, Error>;
    async fn wallet_verify(&self, address: String, uint8s: Vec<u8>, signature: Option<Signature>) -> Result<bool, Error>;
    async fn web3_client_version(&self) -> Result<String, Error>;
}

#[derive(Debug, Clone)]
pub struct FullNodeClient {
    client: LotusClient,
}

impl FullNodeClient {
    pub fn new(client: LotusClient) -> Self {
        Self { client }
    }
}

#[async_trait::async_trait]
impl FullNodeApi for FullNodeClient {
    async fn auth_new(&self, permissions: Vec<String>) -> Result<Vec<u8>, Error> {
        let params = vec![
            serde_json::to_value(&permissions).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.AuthNew", params).await
    }

    async fn auth_verify(&self, string: String) -> Result<Vec<String>, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.AuthVerify", params).await
    }

    async fn chain_blockstore_info(&self) -> Result<HashMap<String, Value>, Error> {
        let params = vec![];
        self.client.request("Filecoin.ChainBlockstoreInfo", params).await
    }

    async fn chain_check_blockstore(&self) -> Result<(), Error> {
        let params = vec![];
        self.client.request::<()>("Filecoin.ChainCheckBlockstore", params).await
    }

    async fn chain_delete_obj(&self, cid: Cid) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ChainDeleteObj", params).await
    }

    async fn chain_export(&self, chain_epoch: i64, bool: bool, tip_set_key: Option<TipSetKey>) -> Result<mpsc::Receiver<Vec<u8>>, Error> {
        let params = vec![
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.subscribe("Filecoin.ChainExport", params).await
    }

    async fn chain_export_range_internal(&self, tip_set_key: Option<TipSetKey>, tip_set_key1: Option<TipSetKey>, chain_export_config: ChainExportConfig) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_export_config).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ChainExportRangeInternal", params).await
    }

    async fn chain_get_block(&self, cid: Cid) -> Result<Option<BlockHeader>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetBlock", params).await
    }

    async fn chain_get_block_messages(&self, cid: Cid) -> Result<Option<BlockMessages>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetBlockMessages", params).await
    }

    async fn chain_get_events(&self, cid: Cid) -> Result<Vec<Event>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetEvents", params).await
    }

    async fn chain_get_genesis(&self) -> Result<Option<TipSet>, Error> {
        let params = vec![];
        self.client.request("Filecoin.ChainGetGenesis", params).await
    }

    async fn chain_get_message(&self, cid: Cid) -> Result<Option<Message>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetMessage", params).await
    }

    async fn chain_get_messages_in_tipset(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<Message>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetMessagesInTipset", params).await
    }

    async fn chain_get_node(&self, string: String) -> Result<Option<IpldObject>, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetNode", params).await
    }

    async fn chain_get_parent_messages(&self, cid: Cid) -> Result<Vec<Message>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetParentMessages", params).await
    }

    async fn chain_get_parent_receipts(&self, cid: Cid) -> Result<Vec<Option<MessageReceipt>>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetParentReceipts", params).await
    }

    async fn chain_get_path(&self, tip_set_key: Option<TipSetKey>, tip_set_key1: Option<TipSetKey>) -> Result<Vec<Option<HeadChange>>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetPath", params).await
    }

    async fn chain_get_tip_set(&self, tip_set_key: Option<TipSetKey>) -> Result<Option<TipSet>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetTipSet", params).await
    }

    async fn chain_get_tip_set_after_height(&self, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<Option<TipSet>, Error> {
        let params = vec![
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetTipSetAfterHeight", params).await
    }

    async fn chain_get_tip_set_by_height(&self, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<Option<TipSet>, Error> {
        let params = vec![
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainGetTipSetByHeight", params).await
    }

    async fn chain_has_obj(&self, cid: Cid) -> Result<bool, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainHasObj", params).await
    }

    async fn chain_head(&self) -> Result<Option<TipSet>, Error> {
        let params = vec![];
        self.client.request("Filecoin.ChainHead", params).await
    }

    async fn chain_hot_gc(&self, hot_gc_opts: HotGCOpts) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&hot_gc_opts).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ChainHotGC", params).await
    }

    async fn chain_notify(&self) -> Result<mpsc::Receiver<Vec<Option<HeadChange>>>, Error> {
        let params = vec![];
        self.client.subscribe("Filecoin.ChainNotify", params).await
    }

    async fn chain_prune(&self, prune_opts: PruneOpts) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&prune_opts).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ChainPrune", params).await
    }

    async fn chain_put_obj(&self, block: Value) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&block).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ChainPutObj", params).await
    }

    async fn chain_read_obj(&self, cid: Cid) -> Result<Vec<u8>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainReadObj", params).await
    }

    async fn chain_set_head(&self, tip_set_key: Option<TipSetKey>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.ChainSetHead", params).await
    }

    async fn chain_stat_obj(&self, cid: Cid, cid1: Cid) -> Result<ObjStat, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainStatObj", params).await
    }

    async fn chain_tip_set_weight(&self, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.ChainTipSetWeight", params).await
    }

    async fn closing(&self) -> Result<mpsc::Receiver<()>, Error> {
        let params = vec![];
        self.client.subscribe("Filecoin.Closing", params).await
    }

    async fn create_backup(&self, string: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.CreateBackup", params).await
    }

    async fn discover(&self) -> Result<HashMap<String, Value>, Error> {
        let params = vec![];
        self.client.request("Filecoin.Discover", params).await
    }

    async fn eth_accounts(&self) -> Result<Vec<[u8; 20]>, Error> {
        let params = vec![];
        self.client.request("Filecoin.EthAccounts", params).await
    }

    async fn eth_address_to_filecoin_address(&self, eth_address: [u8; 20]) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&eth_address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthAddressToFilecoinAddress", params).await
    }

    async fn eth_block_number(&self) -> Result<u64, Error> {
        let params = vec![];
        self.client.request("Filecoin.EthBlockNumber", params).await
    }

    async fn eth_call(&self, eth_call: EthCall, eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<u8>, Error> {
        let params = vec![
            serde_json::to_value(&eth_call).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&eth_block_number_or_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthCall", params).await
    }

    async fn eth_chain_id(&self) -> Result<u64, Error> {
        let params = vec![];
        self.client.request("Filecoin.EthChainId", params).await
    }

    async fn eth_estimate_gas(&self, uint8s: Vec<u8>) -> Result<u64, Error> {
        let params = vec![
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthEstimateGas", params).await
    }

    async fn eth_fee_history(&self, uint8s: Vec<u8>) -> Result<EthFeeHistory, Error> {
        let params = vec![
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthFeeHistory", params).await
    }

    async fn eth_gas_price(&self) -> Result<EthBigInt, Error> {
        let params = vec![];
        self.client.request("Filecoin.EthGasPrice", params).await
    }

    async fn eth_get_balance(&self, eth_address: [u8; 20], eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<EthBigInt, Error> {
        let params = vec![
            serde_json::to_value(&eth_address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&eth_block_number_or_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetBalance", params).await
    }

    async fn eth_get_block_by_hash(&self, eth_hash: [u8; 32], bool: bool) -> Result<EthBlock, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetBlockByHash", params).await
    }

    async fn eth_get_block_by_number(&self, string: String, bool: bool) -> Result<EthBlock, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetBlockByNumber", params).await
    }

    async fn eth_get_block_receipts(&self, eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<Option<EthTxReceipt>>, Error> {
        let params = vec![
            serde_json::to_value(&eth_block_number_or_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetBlockReceipts", params).await
    }

    async fn eth_get_block_receipts_limited(&self, eth_block_number_or_hash: EthBlockNumberOrHash, chain_epoch: i64) -> Result<Vec<Option<EthTxReceipt>>, Error> {
        let params = vec![
            serde_json::to_value(&eth_block_number_or_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetBlockReceiptsLimited", params).await
    }

    async fn eth_get_block_transaction_count_by_hash(&self, eth_hash: [u8; 32]) -> Result<u64, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetBlockTransactionCountByHash", params).await
    }

    async fn eth_get_block_transaction_count_by_number(&self, eth_uint64: u64) -> Result<u64, Error> {
        let params = vec![
            serde_json::to_value(&eth_uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetBlockTransactionCountByNumber", params).await
    }

    async fn eth_get_code(&self, eth_address: [u8; 20], eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<u8>, Error> {
        let params = vec![
            serde_json::to_value(&eth_address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&eth_block_number_or_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetCode", params).await
    }

    async fn eth_get_filter_changes(&self, eth_filter_id: [u8; 32]) -> Result<Option<EthFilterResult>, Error> {
        let params = vec![
            serde_json::to_value(&eth_filter_id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetFilterChanges", params).await
    }

    async fn eth_get_filter_logs(&self, eth_filter_id: [u8; 32]) -> Result<Option<EthFilterResult>, Error> {
        let params = vec![
            serde_json::to_value(&eth_filter_id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetFilterLogs", params).await
    }

    async fn eth_get_logs(&self, eth_filter_spec: Option<EthFilterSpec>) -> Result<Option<EthFilterResult>, Error> {
        let params = vec![
            serde_json::to_value(&eth_filter_spec).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetLogs", params).await
    }

    async fn eth_get_message_cid_by_transaction_hash(&self, eth_hash: Option<[u8; 32]>) -> Result<Option<Cid>, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetMessageCidByTransactionHash", params).await
    }

    async fn eth_get_storage_at(&self, eth_address: [u8; 20], uint8s: Vec<u8>, eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<Vec<u8>, Error> {
        let params = vec![
            serde_json::to_value(&eth_address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&eth_block_number_or_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetStorageAt", params).await
    }

    async fn eth_get_transaction_by_block_hash_and_index(&self, eth_hash: [u8; 32], eth_uint64: u64) -> Result<EthTx, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&eth_uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetTransactionByBlockHashAndIndex", params).await
    }

    async fn eth_get_transaction_by_block_number_and_index(&self, eth_uint64: u64, eth_uint641: u64) -> Result<EthTx, Error> {
        let params = vec![
            serde_json::to_value(&eth_uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&eth_uint641).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetTransactionByBlockNumberAndIndex", params).await
    }

    async fn eth_get_transaction_by_hash(&self, eth_hash: Option<[u8; 32]>) -> Result<Option<EthTx>, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetTransactionByHash", params).await
    }

    async fn eth_get_transaction_by_hash_limited(&self, eth_hash: Option<[u8; 32]>, chain_epoch: i64) -> Result<Option<EthTx>, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetTransactionByHashLimited", params).await
    }

    async fn eth_get_transaction_count(&self, eth_address: [u8; 20], eth_block_number_or_hash: EthBlockNumberOrHash) -> Result<u64, Error> {
        let params = vec![
            serde_json::to_value(&eth_address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&eth_block_number_or_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetTransactionCount", params).await
    }

    async fn eth_get_transaction_hash_by_cid(&self, cid: Cid) -> Result<Option<[u8; 32]>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetTransactionHashByCid", params).await
    }

    async fn eth_get_transaction_receipt(&self, eth_hash: [u8; 32]) -> Result<Option<EthTxReceipt>, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetTransactionReceipt", params).await
    }

    async fn eth_get_transaction_receipt_limited(&self, eth_hash: [u8; 32], chain_epoch: i64) -> Result<Option<EthTxReceipt>, Error> {
        let params = vec![
            serde_json::to_value(&eth_hash).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthGetTransactionReceiptLimited", params).await
    }

    async fn eth_max_priority_fee_per_gas(&self) -> Result<EthBigInt, Error> {
        let params = vec![];
        self.client.request("Filecoin.EthMaxPriorityFeePerGas", params).await
    }

    async fn eth_new_block_filter(&self) -> Result<[u8; 32], Error> {
        let params = vec![];
        self.client.request("Filecoin.EthNewBlockFilter", params).await
    }

    async fn eth_new_filter(&self, eth_filter_spec: Option<EthFilterSpec>) -> Result<[u8; 32], Error> {
        let params = vec![
            serde_json::to_value(&eth_filter_spec).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthNewFilter", params).await
    }

    async fn eth_new_pending_transaction_filter(&self) -> Result<[u8; 32], Error> {
        let params = vec![];
        self.client.request("Filecoin.EthNewPendingTransactionFilter", params).await
    }

    async fn eth_protocol_version(&self) -> Result<u64, Error> {
        let params = vec![];
        self.client.request("Filecoin.EthProtocolVersion", params).await
    }

    async fn eth_send_raw_transaction(&self, uint8s: Vec<u8>) -> Result<[u8; 32], Error> {
        let params = vec![
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthSendRawTransaction", params).await
    }

    async fn eth_send_raw_transaction_untrusted(&self, uint8s: Vec<u8>) -> Result<[u8; 32], Error> {
        let params = vec![
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthSendRawTransactionUntrusted", params).await
    }

    async fn eth_subscribe(&self, uint8s: Vec<u8>) -> Result<[u8; 32], Error> {
        let params = vec![
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthSubscribe", params).await
    }

    async fn eth_syncing(&self) -> Result<EthSyncingResult, Error> {
        let params = vec![];
        self.client.request("Filecoin.EthSyncing", params).await
    }

    async fn eth_trace_block(&self, string: String) -> Result<Vec<Option<EthTraceBlock>>, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthTraceBlock", params).await
    }

    async fn eth_trace_filter(&self, eth_trace_filter_criteria: EthTraceFilterCriteria) -> Result<Vec<Option<EthTraceFilterResult>>, Error> {
        let params = vec![
            serde_json::to_value(&eth_trace_filter_criteria).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthTraceFilter", params).await
    }

    async fn eth_trace_replay_block_transactions(&self, string: String, strings: Vec<String>) -> Result<Vec<Option<EthTraceReplayBlockTransaction>>, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&strings).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthTraceReplayBlockTransactions", params).await
    }

    async fn eth_trace_transaction(&self, string: String) -> Result<Vec<Option<EthTraceTransaction>>, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthTraceTransaction", params).await
    }

    async fn eth_uninstall_filter(&self, eth_filter_id: [u8; 32]) -> Result<bool, Error> {
        let params = vec![
            serde_json::to_value(&eth_filter_id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthUninstallFilter", params).await
    }

    async fn eth_unsubscribe(&self, eth_subscription_id: [u8; 32]) -> Result<bool, Error> {
        let params = vec![
            serde_json::to_value(&eth_subscription_id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.EthUnsubscribe", params).await
    }

    async fn f3_get_certificate(&self, uint64: u64) -> Result<Option<FinalityCertificate>, Error> {
        let params = vec![
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.F3GetCertificate", params).await
    }

    async fn f3_get_ec_power_table(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<PowerEntry>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.F3GetECPowerTable", params).await
    }

    async fn f3_get_f3_power_table(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<PowerEntry>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.F3GetF3PowerTable", params).await
    }

    async fn f3_get_latest_certificate(&self) -> Result<Option<FinalityCertificate>, Error> {
        let params = vec![];
        self.client.request("Filecoin.F3GetLatestCertificate", params).await
    }

    async fn f3_get_manifest(&self) -> Result<Option<Manifest>, Error> {
        let params = vec![];
        self.client.request("Filecoin.F3GetManifest", params).await
    }

    async fn f3_get_or_renew_participation_ticket(&self, address: String, uint8s: Vec<u8>, uint64: u64) -> Result<Vec<u8>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.F3GetOrRenewParticipationTicket", params).await
    }

    async fn f3_get_progress(&self) -> Result<Instant, Error> {
        let params = vec![];
        self.client.request("Filecoin.F3GetProgress", params).await
    }

    async fn f3_is_running(&self) -> Result<bool, Error> {
        let params = vec![];
        self.client.request("Filecoin.F3IsRunning", params).await
    }

    async fn f3_list_participants(&self) -> Result<Vec<F3Participant>, Error> {
        let params = vec![];
        self.client.request("Filecoin.F3ListParticipants", params).await
    }

    async fn f3_participate(&self, uint8s: Vec<u8>) -> Result<F3ParticipationLease, Error> {
        let params = vec![
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.F3Participate", params).await
    }

    async fn filecoin_address_to_eth_address(&self, uint8s: Vec<u8>) -> Result<[u8; 20], Error> {
        let params = vec![
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.FilecoinAddressToEthAddress", params).await
    }

    async fn gas_estimate_fee_cap(&self, message: Option<Message>, int64: i64, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&message).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.GasEstimateFeeCap", params).await
    }

    async fn gas_estimate_gas_limit(&self, message: Option<Message>, tip_set_key: Option<TipSetKey>) -> Result<i64, Error> {
        let params = vec![
            serde_json::to_value(&message).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.GasEstimateGasLimit", params).await
    }

    async fn gas_estimate_gas_premium(&self, uint64: u64, address: String, int64: i64, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.GasEstimateGasPremium", params).await
    }

    async fn gas_estimate_message_gas(&self, message: Option<Message>, message_send_spec: Option<MessageSendSpec>, tip_set_key: Option<TipSetKey>) -> Result<Option<Message>, Error> {
        let params = vec![
            serde_json::to_value(&message).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&message_send_spec).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.GasEstimateMessageGas", params).await
    }

    async fn get_actor_events_raw(&self, actor_event_filter: Option<ActorEventFilter>) -> Result<Vec<Option<ActorEvent>>, Error> {
        let params = vec![
            serde_json::to_value(&actor_event_filter).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.GetActorEventsRaw", params).await
    }

    async fn id(&self) -> Result<String, Error> {
        let params = vec![];
        self.client.request("Filecoin.ID", params).await
    }

    async fn log_alerts(&self) -> Result<Vec<Alert>, Error> {
        let params = vec![];
        self.client.request("Filecoin.LogAlerts", params).await
    }

    async fn log_list(&self) -> Result<Vec<String>, Error> {
        let params = vec![];
        self.client.request("Filecoin.LogList", params).await
    }

    async fn log_set_level(&self, string: String, string1: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&string1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.LogSetLevel", params).await
    }

    async fn market_add_balance(&self, address: String, address1: String, int: String) -> Result<Cid, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MarketAddBalance", params).await
    }

    async fn market_get_reserved(&self, address: String) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MarketGetReserved", params).await
    }

    async fn market_release_funds(&self, address: String, int: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.MarketReleaseFunds", params).await
    }

    async fn market_reserve_funds(&self, address: String, address1: String, int: String) -> Result<Cid, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MarketReserveFunds", params).await
    }

    async fn market_withdraw(&self, address: String, address1: String, int: String) -> Result<Cid, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MarketWithdraw", params).await
    }

    async fn miner_create_block(&self, block_template: Option<BlockTemplate>) -> Result<Option<BlockMsg>, Error> {
        let params = vec![
            serde_json::to_value(&block_template).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MinerCreateBlock", params).await
    }

    async fn miner_get_base_info(&self, address: String, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<Option<MiningBaseInfo>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MinerGetBaseInfo", params).await
    }

    async fn mpool_batch_push(&self, s: Vec<Option<SignedMessage>>) -> Result<Vec<Cid>, Error> {
        let params = vec![
            serde_json::to_value(&s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolBatchPush", params).await
    }

    async fn mpool_batch_push_message(&self, s: Vec<Option<Message>>, message_send_spec: Option<MessageSendSpec>) -> Result<Vec<Option<SignedMessage>>, Error> {
        let params = vec![
            serde_json::to_value(&s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&message_send_spec).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolBatchPushMessage", params).await
    }

    async fn mpool_batch_push_untrusted(&self, s: Vec<Option<SignedMessage>>) -> Result<Vec<Cid>, Error> {
        let params = vec![
            serde_json::to_value(&s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolBatchPushUntrusted", params).await
    }

    async fn mpool_check_messages(&self, s: Vec<Option<MessagePrototype>>) -> Result<Vec<Vec<MessageCheckStatus>>, Error> {
        let params = vec![
            serde_json::to_value(&s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolCheckMessages", params).await
    }

    async fn mpool_check_pending_messages(&self, address: String) -> Result<Vec<Vec<MessageCheckStatus>>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolCheckPendingMessages", params).await
    }

    async fn mpool_check_replace_messages(&self, s: Vec<Option<Message>>) -> Result<Vec<Vec<MessageCheckStatus>>, Error> {
        let params = vec![
            serde_json::to_value(&s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolCheckReplaceMessages", params).await
    }

    async fn mpool_clear(&self, bool: bool) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.MpoolClear", params).await
    }

    async fn mpool_get_config(&self) -> Result<Option<MpoolConfig>, Error> {
        let params = vec![];
        self.client.request("Filecoin.MpoolGetConfig", params).await
    }

    async fn mpool_get_nonce(&self, address: String) -> Result<u64, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolGetNonce", params).await
    }

    async fn mpool_pending(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<Option<SignedMessage>>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolPending", params).await
    }

    async fn mpool_push(&self, signed_message: Option<SignedMessage>) -> Result<Cid, Error> {
        let params = vec![
            serde_json::to_value(&signed_message).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolPush", params).await
    }

    async fn mpool_push_message(&self, message: Option<Message>, message_send_spec: Option<MessageSendSpec>) -> Result<Option<SignedMessage>, Error> {
        let params = vec![
            serde_json::to_value(&message).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&message_send_spec).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolPushMessage", params).await
    }

    async fn mpool_push_untrusted(&self, signed_message: Option<SignedMessage>) -> Result<Cid, Error> {
        let params = vec![
            serde_json::to_value(&signed_message).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolPushUntrusted", params).await
    }

    async fn mpool_select(&self, tip_set_key: Option<TipSetKey>, float64: f64) -> Result<Vec<Option<SignedMessage>>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&float64).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MpoolSelect", params).await
    }

    async fn mpool_set_config(&self, mpool_config: Option<MpoolConfig>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&mpool_config).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.MpoolSetConfig", params).await
    }

    async fn mpool_sub(&self) -> Result<mpsc::Receiver<MpoolUpdate>, Error> {
        let params = vec![];
        self.client.subscribe("Filecoin.MpoolSub", params).await
    }

    async fn msig_add_approve(&self, address: String, address1: String, uint64: u64, address2: String, address3: String, bool: bool) -> Result<Option<MessagePrototype>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address2).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address3).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigAddApprove", params).await
    }

    async fn msig_add_cancel(&self, address: String, address1: String, uint64: u64, address2: String, bool: bool) -> Result<Option<MessagePrototype>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address2).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigAddCancel", params).await
    }

    async fn msig_add_propose(&self, address: String, address1: String, address2: String, bool: bool) -> Result<Option<MessagePrototype>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address2).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigAddPropose", params).await
    }

    async fn msig_approve(&self, address: String, uint64: u64, address1: String) -> Result<Option<MessagePrototype>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigApprove", params).await
    }

    async fn msig_approve_txn_hash(&self, address: String, uint64: u64, address1: String, address2: String, int: String, address3: String, uint641: u64, uint8s: Vec<u8>) -> Result<Option<MessagePrototype>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address2).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address3).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint641).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigApproveTxnHash", params).await
    }

    async fn msig_cancel(&self, address: String, uint64: u64, address1: String) -> Result<Option<MessagePrototype>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigCancel", params).await
    }

    async fn msig_cancel_txn_hash(&self, address: String, uint64: u64, address1: String, int: String, address2: String, uint641: u64, uint8s: Vec<u8>) -> Result<Option<MessagePrototype>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address2).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint641).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigCancelTxnHash", params).await
    }

    async fn msig_create(&self, uint64: u64, addresss: Vec<String>, chain_epoch: i64, int: String, address: String, int1: String) -> Result<Option<MessagePrototype>, Error> {
        let params = vec![
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&addresss).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigCreate", params).await
    }

    async fn msig_get_available_balance(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigGetAvailableBalance", params).await
    }

    async fn msig_get_pending(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Vec<Option<MsigTransaction>>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigGetPending", params).await
    }

    async fn msig_get_vested(&self, address: String, tip_set_key: Option<TipSetKey>, tip_set_key1: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigGetVested", params).await
    }

    async fn msig_get_vesting_schedule(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MsigVesting, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigGetVestingSchedule", params).await
    }

    async fn msig_propose(&self, address: String, address1: String, int: String, address2: String, uint64: u64, uint8s: Vec<u8>) -> Result<Option<MessagePrototype>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address2).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigPropose", params).await
    }

    async fn msig_remove_signer(&self, address: String, address1: String, address2: String, bool: bool) -> Result<Option<MessagePrototype>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address2).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigRemoveSigner", params).await
    }

    async fn msig_swap_approve(&self, address: String, address1: String, uint64: u64, address2: String, address3: String, address4: String) -> Result<Option<MessagePrototype>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address2).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address3).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address4).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigSwapApprove", params).await
    }

    async fn msig_swap_cancel(&self, address: String, address1: String, uint64: u64, address2: String, address3: String) -> Result<Option<MessagePrototype>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address2).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address3).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigSwapCancel", params).await
    }

    async fn msig_swap_propose(&self, address: String, address1: String, address2: String, address3: String) -> Result<Option<MessagePrototype>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address2).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address3).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.MsigSwapPropose", params).await
    }

    async fn net_addrs_listen(&self) -> Result<AddrInfo, Error> {
        let params = vec![];
        self.client.request("Filecoin.NetAddrsListen", params).await
    }

    async fn net_agent_version(&self, id: String) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.NetAgentVersion", params).await
    }

    async fn net_auto_nat_status(&self) -> Result<NatInfo, Error> {
        let params = vec![];
        self.client.request("Filecoin.NetAutoNatStatus", params).await
    }

    async fn net_bandwidth_stats(&self) -> Result<Stats, Error> {
        let params = vec![];
        self.client.request("Filecoin.NetBandwidthStats", params).await
    }

    async fn net_bandwidth_stats_by_peer(&self) -> Result<HashMap<String, Stats>, Error> {
        let params = vec![];
        self.client.request("Filecoin.NetBandwidthStatsByPeer", params).await
    }

    async fn net_bandwidth_stats_by_protocol(&self) -> Result<HashMap<String, Stats>, Error> {
        let params = vec![];
        self.client.request("Filecoin.NetBandwidthStatsByProtocol", params).await
    }

    async fn net_block_add(&self, net_block_list: NetBlockList) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&net_block_list).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.NetBlockAdd", params).await
    }

    async fn net_block_list(&self) -> Result<NetBlockList, Error> {
        let params = vec![];
        self.client.request("Filecoin.NetBlockList", params).await
    }

    async fn net_block_remove(&self, net_block_list: NetBlockList) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&net_block_list).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.NetBlockRemove", params).await
    }

    async fn net_connect(&self, addr_info: AddrInfo) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&addr_info).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.NetConnect", params).await
    }

    async fn net_connectedness(&self, id: String) -> Result<i32, Error> {
        let params = vec![
            serde_json::to_value(&id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.NetConnectedness", params).await
    }

    async fn net_disconnect(&self, id: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.NetDisconnect", params).await
    }

    async fn net_find_peer(&self, id: String) -> Result<AddrInfo, Error> {
        let params = vec![
            serde_json::to_value(&id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.NetFindPeer", params).await
    }

    async fn net_limit(&self, string: String) -> Result<NetLimit, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.NetLimit", params).await
    }

    async fn net_listening(&self) -> Result<bool, Error> {
        let params = vec![];
        self.client.request("Filecoin.NetListening", params).await
    }

    async fn net_peer_info(&self, id: String) -> Result<Option<ExtendedPeerInfo>, Error> {
        let params = vec![
            serde_json::to_value(&id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.NetPeerInfo", params).await
    }

    async fn net_peers(&self) -> Result<Vec<AddrInfo>, Error> {
        let params = vec![];
        self.client.request("Filecoin.NetPeers", params).await
    }

    async fn net_ping(&self, id: String) -> Result<i64, Error> {
        let params = vec![
            serde_json::to_value(&id).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.NetPing", params).await
    }

    async fn net_protect_add(&self, ids: Vec<String>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&ids).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.NetProtectAdd", params).await
    }

    async fn net_protect_list(&self) -> Result<Vec<String>, Error> {
        let params = vec![];
        self.client.request("Filecoin.NetProtectList", params).await
    }

    async fn net_protect_remove(&self, ids: Vec<String>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&ids).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.NetProtectRemove", params).await
    }

    async fn net_pubsub_scores(&self) -> Result<Vec<PubsubScore>, Error> {
        let params = vec![];
        self.client.request("Filecoin.NetPubsubScores", params).await
    }

    async fn net_set_limit(&self, string: String, net_limit: NetLimit) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&net_limit).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.NetSetLimit", params).await
    }

    async fn net_stat(&self, string: String) -> Result<NetStat, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.NetStat", params).await
    }

    async fn net_version(&self) -> Result<String, Error> {
        let params = vec![];
        self.client.request("Filecoin.NetVersion", params).await
    }

    async fn node_status(&self, bool: bool) -> Result<NodeStatus, Error> {
        let params = vec![
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.NodeStatus", params).await
    }

    async fn paych_allocate_lane(&self, address: String) -> Result<u64, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychAllocateLane", params).await
    }

    async fn paych_available_funds(&self, address: String) -> Result<Option<ChannelAvailableFunds>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychAvailableFunds", params).await
    }

    async fn paych_available_funds_by_from_to(&self, address: String, address1: String) -> Result<Option<ChannelAvailableFunds>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychAvailableFundsByFromTo", params).await
    }

    async fn paych_collect(&self, address: String) -> Result<Cid, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychCollect", params).await
    }

    async fn paych_fund(&self, address: String, address1: String, int: String) -> Result<Option<ChannelInfo>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychFund", params).await
    }

    async fn paych_get(&self, address: String, address1: String, int: String, paych_get_opts: PaychGetOpts) -> Result<Option<ChannelInfo>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&paych_get_opts).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychGet", params).await
    }

    async fn paych_get_wait_ready(&self, cid: Cid) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychGetWaitReady", params).await
    }

    async fn paych_list(&self) -> Result<Vec<String>, Error> {
        let params = vec![];
        self.client.request("Filecoin.PaychList", params).await
    }

    async fn paych_new_payment(&self, address: String, address1: String, voucher_specs: Vec<VoucherSpec>) -> Result<Option<PaymentInfo>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&address1).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&voucher_specs).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychNewPayment", params).await
    }

    async fn paych_settle(&self, address: String) -> Result<Cid, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychSettle", params).await
    }

    async fn paych_status(&self, address: String) -> Result<Option<PaychStatus>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychStatus", params).await
    }

    async fn paych_voucher_add(&self, address: String, signed_voucher: Option<SignedVoucher>, uint8s: Vec<u8>, int: String) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&signed_voucher).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychVoucherAdd", params).await
    }

    async fn paych_voucher_check_spendable(&self, address: String, signed_voucher: Option<SignedVoucher>, uint8s: Vec<u8>, uint8s1: Vec<u8>) -> Result<bool, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&signed_voucher).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychVoucherCheckSpendable", params).await
    }

    async fn paych_voucher_check_valid(&self, address: String, signed_voucher: Option<SignedVoucher>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&signed_voucher).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.PaychVoucherCheckValid", params).await
    }

    async fn paych_voucher_create(&self, address: String, int: String, uint64: u64) -> Result<Option<VoucherCreateResult>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&int).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychVoucherCreate", params).await
    }

    async fn paych_voucher_list(&self, address: String) -> Result<Vec<Option<SignedVoucher>>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychVoucherList", params).await
    }

    async fn paych_voucher_submit(&self, address: String, signed_voucher: Option<SignedVoucher>, uint8s: Vec<u8>, uint8s1: Vec<u8>) -> Result<Cid, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&signed_voucher).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.PaychVoucherSubmit", params).await
    }

    async fn session(&self) -> Result<[u8; 16], Error> {
        let params = vec![];
        self.client.request("Filecoin.Session", params).await
    }

    async fn shutdown(&self) -> Result<(), Error> {
        let params = vec![];
        self.client.request::<()>("Filecoin.Shutdown", params).await
    }

    async fn start_time(&self) -> Result<Time, Error> {
        let params = vec![];
        self.client.request("Filecoin.StartTime", params).await
    }

    async fn state_account_key(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateAccountKey", params).await
    }

    async fn state_actor_code_ci_ds(&self, version: u32) -> Result<HashMap<String, Cid>, Error> {
        let params = vec![
            serde_json::to_value(&version).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateActorCodeCIDs", params).await
    }

    async fn state_actor_manifest_cid(&self, version: u32) -> Result<Cid, Error> {
        let params = vec![
            serde_json::to_value(&version).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateActorManifestCID", params).await
    }

    async fn state_all_miner_faults(&self, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<Vec<Option<Fault>>, Error> {
        let params = vec![
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateAllMinerFaults", params).await
    }

    async fn state_call(&self, message: Option<Message>, tip_set_key: Option<TipSetKey>) -> Result<Option<InvocResult>, Error> {
        let params = vec![
            serde_json::to_value(&message).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateCall", params).await
    }

    async fn state_changed_actors(&self, cid: Cid, cid1: Cid) -> Result<HashMap<String, ActorV5>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid1).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateChangedActors", params).await
    }

    async fn state_circulating_supply(&self, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateCirculatingSupply", params).await
    }

    async fn state_compute(&self, chain_epoch: i64, s: Vec<Option<Message>>, tip_set_key: Option<TipSetKey>) -> Result<Option<ComputeStateOutput>, Error> {
        let params = vec![
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateCompute", params).await
    }

    async fn state_compute_data_cid(&self, address: String, registered_seal_proof: i64, deal_ids: Vec<u64>, tip_set_key: Option<TipSetKey>) -> Result<Cid, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&registered_seal_proof).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&deal_ids).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateComputeDataCID", params).await
    }

    async fn state_deal_provider_collateral_bounds(&self, padded_piece_size: u64, bool: bool, tip_set_key: Option<TipSetKey>) -> Result<DealCollateralBounds, Error> {
        let params = vec![
            serde_json::to_value(&padded_piece_size).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateDealProviderCollateralBounds", params).await
    }

    async fn state_decode_params(&self, address: String, method_num: u64, uint8s: Vec<u8>, tip_set_key: Option<TipSetKey>) -> Result<Value, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&method_num).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateDecodeParams", params).await
    }

    async fn state_encode_params(&self, cid: Cid, method_num: u64, uint8s: Vec<u8>) -> Result<Vec<u8>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&method_num).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateEncodeParams", params).await
    }

    async fn state_get_actor(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<ActorV5>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetActor", params).await
    }

    async fn state_get_all_allocations(&self, tip_set_key: Option<TipSetKey>) -> Result<HashMap<u64, Allocation>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetAllAllocations", params).await
    }

    async fn state_get_all_claims(&self, tip_set_key: Option<TipSetKey>) -> Result<HashMap<u64, Claim>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetAllClaims", params).await
    }

    async fn state_get_allocation(&self, address: String, allocation_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<Allocation>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&allocation_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetAllocation", params).await
    }

    async fn state_get_allocation_for_pending_deal(&self, deal_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<Allocation>, Error> {
        let params = vec![
            serde_json::to_value(&deal_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetAllocationForPendingDeal", params).await
    }

    async fn state_get_allocation_id_for_pending_deal(&self, deal_id: u64, tip_set_key: Option<TipSetKey>) -> Result<u64, Error> {
        let params = vec![
            serde_json::to_value(&deal_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetAllocationIdForPendingDeal", params).await
    }

    async fn state_get_allocations(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<HashMap<u64, Allocation>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetAllocations", params).await
    }

    async fn state_get_beacon_entry(&self, chain_epoch: i64) -> Result<Option<BeaconEntry>, Error> {
        let params = vec![
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetBeaconEntry", params).await
    }

    async fn state_get_claim(&self, address: String, claim_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<Claim>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&claim_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetClaim", params).await
    }

    async fn state_get_claims(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<HashMap<u64, Claim>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetClaims", params).await
    }

    async fn state_get_network_params(&self) -> Result<Option<NetworkParams>, Error> {
        let params = vec![];
        self.client.request("Filecoin.StateGetNetworkParams", params).await
    }

    async fn state_get_randomness_digest_from_beacon(&self, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetRandomnessDigestFromBeacon", params).await
    }

    async fn state_get_randomness_digest_from_tickets(&self, chain_epoch: i64, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetRandomnessDigestFromTickets", params).await
    }

    async fn state_get_randomness_from_beacon(&self, domain_separation_tag: i64, chain_epoch: i64, uint8s: Vec<u8>, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&domain_separation_tag).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetRandomnessFromBeacon", params).await
    }

    async fn state_get_randomness_from_tickets(&self, domain_separation_tag: i64, chain_epoch: i64, uint8s: Vec<u8>, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&domain_separation_tag).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateGetRandomnessFromTickets", params).await
    }

    async fn state_list_actors(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<String>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateListActors", params).await
    }

    async fn state_list_messages(&self, message_match: Option<MessageMatch>, tip_set_key: Option<TipSetKey>, chain_epoch: i64) -> Result<Vec<Cid>, Error> {
        let params = vec![
            serde_json::to_value(&message_match).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateListMessages", params).await
    }

    async fn state_list_miners(&self, tip_set_key: Option<TipSetKey>) -> Result<Vec<String>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateListMiners", params).await
    }

    async fn state_lookup_id(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateLookupID", params).await
    }

    async fn state_lookup_robust_address(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateLookupRobustAddress", params).await
    }

    async fn state_market_balance(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MarketBalance, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMarketBalance", params).await
    }

    async fn state_market_deals(&self, tip_set_key: Option<TipSetKey>) -> Result<HashMap<String, Option<MarketDeal>>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMarketDeals", params).await
    }

    async fn state_market_participants(&self, tip_set_key: Option<TipSetKey>) -> Result<HashMap<String, MarketBalance>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMarketParticipants", params).await
    }

    async fn state_market_storage_deal(&self, deal_id: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<MarketDeal>, Error> {
        let params = vec![
            serde_json::to_value(&deal_id).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMarketStorageDeal", params).await
    }

    async fn state_miner_active_sectors(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Vec<Option<SectorOnChainInfo>>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerActiveSectors", params).await
    }

    async fn state_miner_allocated(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<BitField>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerAllocated", params).await
    }

    async fn state_miner_available_balance(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerAvailableBalance", params).await
    }

    async fn state_miner_deadlines(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Vec<Deadline>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerDeadlines", params).await
    }

    async fn state_miner_faults(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<BitField, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerFaults", params).await
    }

    async fn state_miner_info(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MinerInfo, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerInfo", params).await
    }

    async fn state_miner_initial_pledge_collateral(&self, address: String, sector_pre_commit_info: SectorPreCommitInfo, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_pre_commit_info).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerInitialPledgeCollateral", params).await
    }

    async fn state_miner_initial_pledge_for_sector(&self, chain_epoch: i64, sector_size: u64, uint64: u64, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_size).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerInitialPledgeForSector", params).await
    }

    async fn state_miner_partitions(&self, address: String, uint64: u64, tip_set_key: Option<TipSetKey>) -> Result<Vec<Partition>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerPartitions", params).await
    }

    async fn state_miner_power(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<MinerPower>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerPower", params).await
    }

    async fn state_miner_pre_commit_deposit_for_power(&self, address: String, sector_pre_commit_info: SectorPreCommitInfo, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_pre_commit_info).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerPreCommitDepositForPower", params).await
    }

    async fn state_miner_proving_deadline(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<Info>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerProvingDeadline", params).await
    }

    async fn state_miner_recoveries(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<BitField, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerRecoveries", params).await
    }

    async fn state_miner_sector_allocated(&self, address: String, sector_number: u64, tip_set_key: Option<TipSetKey>) -> Result<bool, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_number).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerSectorAllocated", params).await
    }

    async fn state_miner_sector_count(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<MinerSectors, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerSectorCount", params).await
    }

    async fn state_miner_sectors(&self, address: String, bit_field: Option<BitField>, tip_set_key: Option<TipSetKey>) -> Result<Vec<Option<SectorOnChainInfo>>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bit_field).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateMinerSectors", params).await
    }

    async fn state_network_name(&self) -> Result<String, Error> {
        let params = vec![];
        self.client.request("Filecoin.StateNetworkName", params).await
    }

    async fn state_network_version(&self, tip_set_key: Option<TipSetKey>) -> Result<u32, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateNetworkVersion", params).await
    }

    async fn state_read_state(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<ActorState>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateReadState", params).await
    }

    async fn state_replay(&self, tip_set_key: Option<TipSetKey>, cid: Cid) -> Result<Option<InvocResult>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateReplay", params).await
    }

    async fn state_search_msg(&self, tip_set_key: Option<TipSetKey>, cid: Cid, chain_epoch: i64, bool: bool) -> Result<Option<MsgLookup>, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateSearchMsg", params).await
    }

    async fn state_sector_expiration(&self, address: String, sector_number: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<SectorExpiration>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_number).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateSectorExpiration", params).await
    }

    async fn state_sector_get_info(&self, address: String, sector_number: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<SectorOnChainInfo>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_number).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateSectorGetInfo", params).await
    }

    async fn state_sector_partition(&self, address: String, sector_number: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<SectorLocation>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_number).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateSectorPartition", params).await
    }

    async fn state_sector_pre_commit_info(&self, address: String, sector_number: u64, tip_set_key: Option<TipSetKey>) -> Result<Option<SectorPreCommitOnChainInfo>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&sector_number).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateSectorPreCommitInfo", params).await
    }

    async fn state_vm_circulating_supply_internal(&self, tip_set_key: Option<TipSetKey>) -> Result<CirculatingSupply, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateVMCirculatingSupplyInternal", params).await
    }

    async fn state_verified_client_status(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<String>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateVerifiedClientStatus", params).await
    }

    async fn state_verified_registry_root_key(&self, tip_set_key: Option<TipSetKey>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateVerifiedRegistryRootKey", params).await
    }

    async fn state_verifier_status(&self, address: String, tip_set_key: Option<TipSetKey>) -> Result<Option<String>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateVerifierStatus", params).await
    }

    async fn state_wait_msg(&self, cid: Cid, uint64: u64, chain_epoch: i64, bool: bool) -> Result<Option<MsgLookup>, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint64).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&chain_epoch).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&bool).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.StateWaitMsg", params).await
    }

    async fn subscribe_actor_events_raw(&self, actor_event_filter: Option<ActorEventFilter>) -> Result<mpsc::Receiver<Option<ActorEvent>>, Error> {
        let params = vec![
            serde_json::to_value(&actor_event_filter).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.subscribe("Filecoin.SubscribeActorEventsRaw", params).await
    }

    async fn sync_check_bad(&self, cid: Cid) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.SyncCheckBad", params).await
    }

    async fn sync_checkpoint(&self, tip_set_key: Option<TipSetKey>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SyncCheckpoint", params).await
    }

    async fn sync_incoming_blocks(&self) -> Result<mpsc::Receiver<Option<BlockHeader>>, Error> {
        let params = vec![];
        self.client.subscribe("Filecoin.SyncIncomingBlocks", params).await
    }

    async fn sync_mark_bad(&self, cid: Cid) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SyncMarkBad", params).await
    }

    async fn sync_state(&self) -> Result<Option<SyncState>, Error> {
        let params = vec![];
        self.client.request("Filecoin.SyncState", params).await
    }

    async fn sync_submit_block(&self, block_msg: Option<BlockMsg>) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&block_msg).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SyncSubmitBlock", params).await
    }

    async fn sync_unmark_all_bad(&self) -> Result<(), Error> {
        let params = vec![];
        self.client.request::<()>("Filecoin.SyncUnmarkAllBad", params).await
    }

    async fn sync_unmark_bad(&self, cid: Cid) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&cid).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.SyncUnmarkBad", params).await
    }

    async fn sync_validate_tipset(&self, tip_set_key: Option<TipSetKey>) -> Result<bool, Error> {
        let params = vec![
            serde_json::to_value(&tip_set_key).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.SyncValidateTipset", params).await
    }

    async fn version(&self) -> Result<APIVersion, Error> {
        let params = vec![];
        self.client.request("Filecoin.Version", params).await
    }

    async fn wallet_balance(&self, address: String) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.WalletBalance", params).await
    }

    async fn wallet_default_address(&self) -> Result<String, Error> {
        let params = vec![];
        self.client.request("Filecoin.WalletDefaultAddress", params).await
    }

    async fn wallet_delete(&self, address: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.WalletDelete", params).await
    }

    async fn wallet_export(&self, address: String) -> Result<Option<KeyInfo>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.WalletExport", params).await
    }

    async fn wallet_has(&self, address: String) -> Result<bool, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.WalletHas", params).await
    }

    async fn wallet_import(&self, key_info: Option<KeyInfo>) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&key_info).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.WalletImport", params).await
    }

    async fn wallet_list(&self) -> Result<Vec<String>, Error> {
        let params = vec![];
        self.client.request("Filecoin.WalletList", params).await
    }

    async fn wallet_new(&self, key_type: String) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&key_type).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.WalletNew", params).await
    }

    async fn wallet_set_default(&self, address: String) -> Result<(), Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request::<()>("Filecoin.WalletSetDefault", params).await
    }

    async fn wallet_sign(&self, address: String, uint8s: Vec<u8>) -> Result<Option<Signature>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.WalletSign", params).await
    }

    async fn wallet_sign_message(&self, address: String, message: Option<Message>) -> Result<Option<SignedMessage>, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&message).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.WalletSignMessage", params).await
    }

    async fn wallet_validate_address(&self, string: String) -> Result<String, Error> {
        let params = vec![
            serde_json::to_value(&string).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.WalletValidateAddress", params).await
    }

    async fn wallet_verify(&self, address: String, uint8s: Vec<u8>, signature: Option<Signature>) -> Result<bool, Error> {
        let params = vec![
            serde_json::to_value(&address).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&uint8s).map_err(|e| Error::invalid_params(e.to_string()))?,
            serde_json::to_value(&signature).map_err(|e| Error::invalid_params(e.to_string()))?,
        ];
        self.client.request("Filecoin.WalletVerify", params).await
    }

    async fn web3_client_version(&self) -> Result<String, Error> {
        let params = vec![];
        self.client.request("Filecoin.Web3ClientVersion", params).await
    }

}
